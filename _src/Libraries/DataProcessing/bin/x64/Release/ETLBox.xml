<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ETLBox</name>
    </assembly>
    <members>
        <member name="T:ETLBox.Connection.ConnectionManagerType">
            <summary>
            All databases types that ETLBox supports with Connection Managers
            </summary>
        </member>
        <member name="T:ETLBox.Connection.DbConnectionManager`3">
            <summary>
            The generic implementation on which all connection managers are based on
            </summary>
            <typeparam name="TConnection">The underlying ADO.NET connection</typeparam>
            <typeparam name="TTransaction">The transaction type used in the ADO.NET connector</typeparam>
            <typeparam name="TParameter">The parameter type used in the ADO.NET connector</typeparam>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.DbConnection">
            <summary>
            The underlying ADO.NET connection.
            Only read from this object and it's properties - by default, connections are always
            acquired from the connection pool. There is no guarantee that
            the same connection will be used in ETLBox components.
            </summary>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.ConnectionManagerType">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.MaxLoginAttempts">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.LeaveOpen">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.ConnectionString">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.State">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.Transaction">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.IsInBulkInsert">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.QB">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.QE">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.PP">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.SupportDatabases">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.SupportProcedures">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.SupportSchemas">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.IsOdbcOrOleDbConnection">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionManager`3.MaxParameterAmount">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.OverrideConnectionSpecifics(ETLBox.Connection.ConnectionManagerType,System.String,System.String,System.String)">
            <summary>
            Changes the connection manager type for the generic connector, so that
            you can try to use it with not supported setups. 
            If you are looking for supported Odbc connection managers, try to use the specific
            connection managers (e.g. MySqlOdbcConnectionManager for MySql or 
            PostgresOdbcConnectionManager for Postgres)
            </summary>
            <param name="connectionManagerType">The new connection type for this connection manager.</param>
            <param name="QB">Quotation begin (e.g. "`" for MySql or "[" for SqlServer)</param>
            <param name="QE">Quotation end (e.g. "`" for MySql or "]" for SqlServer)</param>
            <param name="PP">Parameter placeholder ("@" for most databases)</param>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.ExecuteNonQuery(System.String,System.Collections.Generic.IEnumerable{ETLBox.ControlFlow.QueryParameter})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.ExecuteScalar(System.String,System.Collections.Generic.IEnumerable{ETLBox.ControlFlow.QueryParameter})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.ExecuteReader(System.String,System.Collections.Generic.IEnumerable{ETLBox.ControlFlow.QueryParameter})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.BeginTransaction(System.Data.IsolationLevel)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.BeginTransaction">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.CommitTransaction">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.RollbackTransaction">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.PrepareBulkInsert(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.BulkInsert(ETLBox.ControlFlow.ITableData)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.CleanUpBulkInsert(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.BulkDelete(ETLBox.ControlFlow.ITableData)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.BulkUpdate(ETLBox.ControlFlow.ITableData,System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.CloneIfAllowed">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.Clone">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.CopyBaseAttributes(ETLBox.Connection.DbConnectionManager{`0,`1,`2})">
            <summary>
            Copeis the connection manager base attribnutes from the current 
            connection manager to the target connection manager. 
            </summary>
            <param name="original">Target of the copy operation</param>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.Open">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.CreateDbConnection">
            <summary>
            By default, a db connection is created with the given connection string value.
            Override this method if you want to pass additional properties to the specific Ado.NET db connection. 
            </summary>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.Close">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.CloseIfAllowed">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionManager`3.Dispose">
            <summary>
            Closes the connection - this will not automatically disconnect
            from the database server, it will only return the connection 
            to the ADO.NET connection pool for further reuse.
            </summary>
        </member>
        <member name="T:ETLBox.Connection.IConnectionManager">
            <summary>
            Common properties and methods for all database connection managers
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.ConnectionManagerType">
            <summary>
            The database type for the connection manager.
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.MaxLoginAttempts">
            <summary>
            Number of attempts that the connection managers tries to connect before it decides that the database is not reachable.
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.CommandTimeout">
            <summary>
            The timeout used when executing sql commands with this connection manager. 
            Default is 0 (no timeout)
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.LeaveOpen">
            <summary>
            By default, after every sql operation the underlying ADO.NET connection is closed and retured to the ADO.NET connection pool.
            (This is the recommended behavior)
            To keep the connection open and avoid having the connection returned to the pool, set this to true.
            A connnection will be left open when a bulk insert operation is executed or a transaction hase been openend and not yet commited or rolled back.
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.ConnectionString">
            <summary>
            The connection string used to establish the connection with the database
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.State">
            <summary>
            The state of the underlying ADO.NET connection
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.QB">
            <summary>
            The quotation begin character that is used in the database.
            E.g. SqlServer uses: '[' and Postgres: '"'
            </summary>        
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.QE">
            <summary>
            The quotation end character that is used in the database.
            E.g. SqlServer uses: ']' and Postgres: '"'
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.PP">
            <summary>
            The character that is used in front of parameter names in query to identify the parameter.
            All databases use the '@' character, except Oracle which uses ':'
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.SupportDatabases">
            <summary>
            Indicates if database server does support multiple databases.
            A database in ETLBox means a schema in MySql.
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.SupportProcedures">
            <summary>
            Indicates if the database supports procedures
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.SupportSchemas">
            <summary>
            Indicates if the database supports schemas
            In MySql, this is false because the schema here is a database in ETLBox.
            Use <see cref="P:ETLBox.Connection.IConnectionManager.SupportDatabases"/> instead
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.IsOdbcOrOleDbConnection">
            <summary>
            Indicates if the current connection manager is used as a OleDb or Odbc Connection.
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.MaxParameterAmount">
            <summary>
            returns the maximum amount of parameters that ca be passed into a
            sql query. 
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.Compatibility">
            <summary>
            Information about compatibility of the current connector
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.ExecuteNonQuery(System.String,System.Collections.Generic.IEnumerable{ETLBox.ControlFlow.QueryParameter})">
            <summary>
            Executes a query against the database that doesn't return any data.
            </summary>
            <param name="command">The sql command</param>
            <param name="parameterList">The optional list of parameters</param>
            <returns>Number of affected rows.</returns>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.ExecuteScalar(System.String,System.Collections.Generic.IEnumerable{ETLBox.ControlFlow.QueryParameter})">
            <summary>
            Executes a query against the database that does return only one row in one column.
            </summary>
            <param name="command">The sql command</param>
            <param name="parameterList">The optional list of parameters</param>
            <returns>The result</returns>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.ExecuteReader(System.String,System.Collections.Generic.IEnumerable{ETLBox.ControlFlow.QueryParameter})">
            <summary>
            Executes a query against the database that does return multiple rows in multiple columns
            </summary>
            <param name="command">The sql command</param>
            <param name="parameterList">The optional list of parameters</param>
            <returns>A data reader to iterate through the result set</returns>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Will start a transaction with the given isolation level (if supported by the target database) 
            This will leave the underlying ADO.NET connection open until the transaction is committed or rolled back.
            </summary>
            <param name="isolationLevel">The isolation level for the transaction</param>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.BeginTransaction">
            <summary>
            Will start a transaction with the default isolation level.
            This will leave the underlying ADO.NET connection open until the transaction is committed or rolled back.
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.CommitTransaction">
            <summary>
            Commits the current tranasction.
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.RollbackTransaction">
            <summary>
            Rolls the current transaction back.
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.CloneIfAllowed">
            <summary>
            Try to create a clone of the current connection - only possible if <see cref="P:ETLBox.Connection.IConnectionManager.LeaveOpen"/> is false.
            </summary>
            <returns>The connection that was either cloned or the current connection</returns>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.Clone">
            <summary>
            Cretes a clone of the current connection manager
            </summary>
            <returns>A instance copy of the current connection manager</returns>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.Open">
            <summary>
            Opens the connection to the database. Normally you don't have to do this on your own,
            as all tasks and components will call this method implictly if the connection is closed.
            If the connection is already open, nothing is done.
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.Close">
            <summary>
            Closes the connection - this will not automatically disconnect
            from the database server, it will only return the connection 
            to the ADO.NET connection pool for further reuse.
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.CloseIfAllowed">
            <summary>
            Closes the connection only if leave open is set to false and no transaction or bulk insert is in progress.
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager.IsInBulkInsert">
            <summary>
            Indicates if the current connection is currently used in a bulk insert operation (e.g. performed by a DbDestination)
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.PrepareBulkInsert(System.String)">
            <summary>
            Performs preparations needed to improved 
            performance of a bulk insert operation
            </summary>
            <param name="tableName">Destination table name</param>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.BulkInsert(ETLBox.ControlFlow.ITableData)">
            <summary>
            Performs a bulk insert
            </summary>
            <param name="data">Batch of data</param>        
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.CleanUpBulkInsert(System.String)">
            <summary>
            Called after the whole bulk insert operation 
            to change back settings made to improve bulk insert performance
            </summary>
            <param name="tableName">Destination table name</param>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.BulkDelete(ETLBox.ControlFlow.ITableData)">
            <summary>
            Performs a bulk delete
            </summary>
            <param name="data">Batch of data</param>        
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.BulkUpdate(ETLBox.ControlFlow.ITableData,System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String})">
            <summary>
            Performs a bulk update
            </summary>
            <param name="data">Batch of data</param>
            <param name="setColumnNames">The column names used in the set part of the update statement</param>
            <param name="joinColumnNames">The column names to join for the update</param>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManager.BulkSelect(ETLBox.ControlFlow.ITableData,System.Collections.Generic.ICollection{System.String},System.Action,System.Action,System.Action{System.Object}[])">
            <summary>
            Performs a bulk select
            </summary>
            <param name="data">Batch of data needed for the where condition</param>
            <param name="selectColumnNames">Column names included in the select</param>
            <param name="beforeRowReadAction">Action invoked before any data is read</param>
            <param name="afterRowReadAction">Action invoked after all data is read</param>
            <param name="actions">Pass an action for each column</param>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManagerDbObjects.ReadTableDefinition(ETLBox.Helper.ObjectNameDescriptor)">
            <summary>
            Describe how the table meta data can be read from the database
            </summary>
            <param name="TN">The formatted table name</param>
            <returns>The definition of the table, containing column names, types, etc. </returns>
        </member>
        <member name="M:ETLBox.Connection.IConnectionManagerDbObjects.CheckIfTableOrViewExists(System.String)">
            <summary>
            Describes how the connection manager can check if a table or view exists
            </summary>
            <param name="objectName">The formatted table or view name</param>
            <returns>True if the table or view exists</returns>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager`2.DbConnection">
            <summary>
            The underlying ADO.NET connection
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IConnectionManager`2.Transaction">
            <summary>
            The current transaction. Use <see cref="M:ETLBox.Connection.IConnectionManager.BeginTransaction"/> to start a transaction,
            and <see cref="M:ETLBox.Connection.IConnectionManager.CommitTransaction"/> or <see cref="M:ETLBox.Connection.IConnectionManager.RollbackTransaction"/> to commit or rollback.
            </summary>
        </member>
        <member name="T:ETLBox.Connection.DbConnectionString`2">
            <summary>
            <see cref="T:ETLBox.Connection.IDbConnectionString"/> base
            </summary>
            <typeparam name="T">Derived type</typeparam>
            <typeparam name="TBuilder">The underlying ADO.NET connection string builder</typeparam>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionString`2.Builder">
            <summary>
            The underlying ADO.NET ConnectionStringBuilder
            </summary>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionString`2.Value">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.ToString">
            <summary>
            Returns the connection string <see cref="P:ETLBox.Connection.DbConnectionString`2.Value"/>
            </summary>
            <returns>The new connection string</returns>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionString`2.DbName">
            <inheritdoc />
        </member>
        <member name="P:ETLBox.Connection.DbConnectionString`2.DbNameKeyword">
            <summary>
            The keyword used in the connection string to identify a database
            </summary>
        </member>
        <member name="P:ETLBox.Connection.DbConnectionString`2.MasterDbName">
            <inheritdoc />
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.ETLBox#Connection#IDbConnectionString#Clone">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.ETLBox#Connection#IDbConnectionString#CloneWithNewDbName(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.ETLBox#Connection#IDbConnectionString#CloneWithMasterDbName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.CloneWithNewDbName(System.String)">
            <summary>
            Clone the current connection string with a new database name
            </summary>
            <param name="value">The new database name</param>
            <returns>The new connection string</returns>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.Clone">
            <summary>
            Clones the current connection string
            </summary>
            <returns>A copy of the current connection string</returns>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.CloneWithoutDbName">
            <summary>
            Clones the current connection string with removing the database name
            </summary>
            <returns>The new connection string without database name</returns>
        </member>
        <member name="M:ETLBox.Connection.DbConnectionString`2.CloneWithMasterDbName">
            <summary>
            Clones the current connection string with the master database name (if applicable)
            </summary>
            <returns>The new connection string with master database name</returns>
        </member>
        <member name="T:ETLBox.Connection.IDbConnectionString">
            <summary>
            The generic defintion of a connection string
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IDbConnectionString.Value">
            <summary>
            The connection string value, e.g. "Server=localhost;Database=etlbox;"
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IDbConnectionString.ToString">
            <summary>
            Returns the connection string <see cref="P:ETLBox.Connection.IDbConnectionString.Value"/>
            </summary>
            <returns>The new connection string</returns>
        </member>
        <member name="M:ETLBox.Connection.IDbConnectionString.Clone">
            <summary>
            Creates a copy of the current connection
            </summary>
            <returns>A copy of the connection string</returns>
        </member>
        <member name="P:ETLBox.Connection.IDbConnectionString.DbName">
            <summary>
            The database name
            </summary>
        </member>
        <member name="P:ETLBox.Connection.IDbConnectionString.MasterDbName">
            <summary>
            The name of the master database (if applicable)
            </summary>
        </member>
        <member name="M:ETLBox.Connection.IDbConnectionString.CloneWithNewDbName(System.String)">
            <summary>
            Clone the current connection string with a new database name
            </summary>
            <param name="value">The new database name</param>
            <returns>The new connection string</returns>
        </member>
        <member name="M:ETLBox.Connection.IDbConnectionString.CloneWithMasterDbName">
            <summary>
            Clone the current connection string with the master database
            </summary>
            <returns>The new connection string</returns>
        </member>
        <member name="T:ETLBox.DataFlow.ColumnMap">
            <summary>
            This attribute defines the mapping between property names in the objects and column names
            in the database. 
            By default, when reading or writing data from/into a database, properties in your objects
            are mapped to database columns with the same name (case-sensitive). Using this attribute, you can 
            add your own mapping. (E.g. a property "Prop1" is mapped by default to the database column "Prop1".
            Create a column mapping to change the mapping to "Column1")
            </summary>
            <example>
            <code>
             public class MyPoco
            {
                [ColumnMap("Column1")]
                public string Prop1 { get; set; }
            }
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.ColumnMap.DbColumnName">
            <summary>
            Name of the database column
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.ColumnMap.#ctor(System.String)">
            <summary>
            Creates a mapping between the a property and a database column        
            </summary>
            <param name="dbColumnName">The name of the column in the database</param>
        </member>
        <member name="P:ETLBox.DataFlow.ColumnMap.ArrayIndex">
            <summary>
            Index of the element in the array, only necessary if you use arrays 
            as data type
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.ColumnMap.PropertyName">
            <summary>
            Name of the property that should be mapped to a database column
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.ColumnMap.IgnoreColumn">
            <summary>
            If set to true, this property will be ignored and not mapped to any column. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GenericTypeInfo.IsPoco">
            <summary>
            Indicates if the type is an strong type object (Plain old CLR object)
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GenericTypeInfo.IsArray">
            <summary>
            Indicates if the type is an array (e.g. string[])
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GenericTypeInfo.IsDynamic">
            <summary>
            Indicates if the type is an ExpandoObject
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GenericTypeInfo.Properties">
            <summary>
            Property info of the type
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GenericTypeInfo.PropertyNames">
            <summary>
            Property names of the type
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GenericTypeInfo.PropertiesByName">
            <summary>
            Property info of the type by property name
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.GenericTypeInfo.IsNumericType(System.Type)">
            <summary>
            Determines if a type is numeric.  Nullable numeric types are considered numeric.        
            </summary>
            <remarks>
            Boolean is not considered numeric.
            http://stackoverflow.com/a/5182747/172132
            </remarks>        
        </member>
        <member name="T:ETLBox.DataFlow.AggregateColumn">
            <summary>
            This attribute is used to identify the aggregation property for aggregations.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AggregateColumn.InputValuePropName">
            <summary>
            Property name in the input object that contains the detailed values.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AggregateColumn.AggregationMethod">
            <summary>
            Method for the aggregation (e.g. Sum, Min, Max, etc.)
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AggregateColumn.AggregatedValuePropName">
            <summary>
            Property name that holds the aggregated value in the output object
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.AggregateColumn.#ctor(System.String,ETLBox.DataFlow.Transformations.AggregationMethod)">
            <summary>
            Sets the property name in the aggregation output object and the aggregation method
            </summary>
            <param name="inputValuePropName">Property name in the input object that contains the detailed values.</param>
            <param name="aggregationMethod">Method for the aggregation (e.g. Sum, Min, Max, etc.)</param>
        </member>
        <member name="T:ETLBox.DataFlow.CompareColumn">
            <summary>
            This attribute defines if the column is included in the comparison to identify
            object that exists and needs to be updated. It it supposed
            to use with an object that either inherits from MergeableRow.
            If you implement the IMergeable interface, you need to override the Equals-method instead.
            </summary>
            <example>
            <code>
             public class MyPoco : MergeableRow
            {
                [IdColumn]
                public int Key { get; set; }
                [CompareColumn]
                public string Value {get;set; }
            }
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.CompareColumn.ComparePropertyName">
            <summary>
            Name of the property name used for the comparison if two rows match 
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.CompareColumn.#ctor">
            <summary>
            Marks this property as column used for comparison in a Merge operation
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.DeleteColumn">
            <summary>
            This attribute defines if the column is used to identify if the record is supposed to be deleted.
            If this attribute is set and the given value matches the column of the assigned property,
            the DbMerge will know that if the records matches (identifed by the IdColumn attribute)
            it should be deleted.
            </summary>
            <example>
             public class MyPoco : MergeableRow
            {
                [IdColumn]
                public int Key { get; set; }
                [UpdateColumn]
                public string Value {get;set; }
                [DeleteColumn(true)]
                public bool IsDeletion {get;set; }
            }
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.DeleteColumn.DeletePropertyName">
            <summary>
            Name of the property that is used to decide if a row is deleted 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DeleteColumn.DeleteOnMatchValue">
            <summary>
            Marks this property as column used for a deletion check in a Merge operation
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.DeleteColumn.#ctor(System.Object)">
            <summary>
            Marks this property as column that is deleted if is equal the  <see cref="P:ETLBox.DataFlow.DeleteColumn.DeleteOnMatchValue"/>.
            </summary>
            <param name="deleteOnMatchValue">To be value for the property that identifes the row as deletion</param>
        </member>
        <member name="T:ETLBox.DataFlow.DistinctColumn">
            <summary>
            This attribute is used to identify distinct properties in an object.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DistinctColumn.DistinctPropertyName">
            <summary>
            Property name used in the object to identify distinct values
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.GroupColumn">
            <summary>
            This attribute is used to identify the grouping property for aggregations. The passed column name
            identifies the property in the aggregation output object.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GroupColumn.GroupPropNameInInput">
            <summary>
            Property name used in the input object for grouping the aggregation.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.GroupColumn.GroupPropNameInOutput">
            <summary>
            Property name that holds the grouping value in the output object
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.GroupColumn.#ctor(System.String)">
            <summary>
            Sets the property name used for grouping in the input object
            </summary>
            <param name="groupPropNameInInput">Property name in the input object used for grouping the aggregation data</param>
        </member>
        <member name="T:ETLBox.DataFlow.IdColumn">
            <summary>
            This attribute defines if the column is used as an Id for the DBMerge. It it supposed
            to use with an object that either inherits from MergeableRow or implements the IMergeable interface.
            If you do not provide this attribute, you need to override the UniqueId property
            if you inherit from MergeableRow.
            </summary>
            <example>
            <code>
            public class MyPoco : MergeableRow
            {
                [IdColumn]
                public int Key { get; set; }
                public string Value {get;set; }
            }
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.IdColumn.IdPropertyName">
            <summary>
            Name of the property used as Id
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.IdColumn.#ctor">
            <summary>
            This property is used as an Id column for a Merge operation.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.KeyColumn">
            <summary>
            This attribute defines if the column is used as as Key when the object is stored in a 
            Key/Value database (e.g. Couchbase or Redis). The key column must either be of type string 
            or implement the ToString() method. 
            </summary>    
            <example>
            <code>
            public class MyPoco : MergeableRow
            {
                [KeyColumn]
                public string KeyName { get; set; }
                public string Value {get;set; }
            }
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.KeyColumn.KeyPropertyName">
            <summary>
            Name of the property used for the Key - must be of type string
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.KeyColumn.#ctor">
            <summary>
            This property is used as an Key column when inserting data into a Key/Value store
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.MatchColumn">
             <summary>
             This attribute defines that this property is used to match with the property of the object
             used in the Source for a Lookup identified by the given lookupSourcePropertyName.
             </summary>
             <example>
             <code>
             public class MyLookupData
             {
                 [MatchColumn("Id")]
                 public string LookupId { get; set; }
                 [RetrieveColumn("Value")]
                 public string LookupValue { get; set; }
             }
            
             public class MyDataRow
             {
                 public string Id { get; set; }
                 public string Value { get; set; }
             }
             </code>
             </example>
        </member>
        <member name="P:ETLBox.DataFlow.MatchColumn.InputPropertyName">
            <summary>
            Name of the property in the input data
            </summary>        
        </member>
        <member name="P:ETLBox.DataFlow.MatchColumn.LookupSourcePropertyName">
            <summary>
            Name of the corresponding column in the lookup object.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.MatchColumn.#ctor(System.String)">
            <summary>
            This property is used to check if is matches with the lookup data .
            </summary>
            <param name="inputPropertyName">Name of the property in the lookup object.</param>
        </member>
        <member name="T:ETLBox.DataFlow.RenameColumn">
            <summary>
            This property can be used in the ColumnRename transformation to rename a column.
            You can rename a property in either your strong typed or dynamic object.    
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.RenameColumn.NewName">
            <summary>
            New name of the column
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.RenameColumn.#ctor(System.String)">
            <summary>
            Contains information for renaming a column in a flow
            </summary>
            <param name="newName">The new name of the column</param>
        </member>
        <member name="P:ETLBox.DataFlow.RenameColumn.CurrentName">
            <summary>
            Current name of the column (not needed if you use this class as an attribute)
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.RenameColumn.ArrayIndex">
            <summary>
            Index of the element in the array, only necessary if you use arrays 
            as data type
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.RenameColumn.RemoveColumn">
            <summary>
            If set to true, this column is left out when using the ColumnRename transformation.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.RetrieveColumn">
             <summary>
             This attribute defines that this property is used to store the lookup value of the property from the object
             used in the Source for a Lookup identified by the given lookupSourcePropertyName.
             </summary>
             <example>
             <code>
             public class MyLookupData
             {
                 [MatchColumn("Id")]
                 public string LookupId { get; set; }
                 [RetrieveColumn("Value")]
                 public string LookupValue { get; set; }
             }
            
             public class MyDataRow
             {
                 public string Id { get; set; }    
                 public string Value { get; set; }
             }
             </code>
             </example>
        </member>
        <member name="P:ETLBox.DataFlow.RetrieveColumn.InputPropertyName">
            <summary>
            Name of the property in the input data
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.RetrieveColumn.LookupSourcePropertyName">
            <summary>
            Name of the corresponding column in the lookup object.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.RetrieveColumn.#ctor(System.String)">
            <summary>
            This property is used to store the retrieved value from the lookup data.
            </summary>
            <param name="inputPropertyName">Name of the property in the lookup object</param>
        </member>
        <member name="T:ETLBox.DataFlow.UpdateColumn">
            <summary>
            This attribute defines if a column is the destination is updated. 
            Use the CompareColumn attribute to define if a row in the source and destination
            match. If they match, you can use the UpdateColumn to describe which columns
            are actually updated. This is optional - if you don't provide any update columns,
            all non id columns are updated. 
            </summary>
            <example>
             public class MyPoco : MergeableRow
            {
                [IdColumn]
                public int Key { get; set; }
                [CompareColumn]
                public string HashValue { get;set; }
                [UpdateColumn]
                public string ValueToUpdate { get;set; }
                public string IgnoredValue { get;set; }
                
            }
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.UpdateColumn.UpdatePropertyName">
            <summary>
            Name of the property that is used in the update
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowBatchDestination`1.BeforeBatchWrite">
            <summary>
            This function is called every time before a batch is inserted into the destination.
            It receives an array that represents the batch - you can modify the data itself if needed.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowBatchDestination`1.AfterBatchWrite">
            <summary>
            This action is called after a batch was successfully inserted into the destination.
            You will get a copy of the data that was used for the insertion.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowBatchDestination`1.BatchSize">
            <summary>
            The batch size defines how many records needs to be in the Input buffer before data is written into the destination.
            The default batch size is 1000.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.DataFlowComponent">
            <summary>
            A base class for data flow components
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.MaxBufferSize">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.Predecessors">
            <summary>
            All predecessors that are linked to this component.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.Successors">
            <summary>
            All successors that this component is linked to.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.Completion">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowComponent.SetParent(ETLBox.DataFlow.DataFlowComponent)">
            <summary>
            Will set another component as a parent component - only needed for constructing subflow 
            inside data flow components. 
            </summary>
            <param name="parent"></param>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowComponent.InitBufferObjects">
            <summary>
            Inits the underlying TPL.Dataflow buffer objects. After this, the component is ready for linking
            its source or target blocks. The initialization is done automatically when 
            a network is executed. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.OnCompletion">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.Exception">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.ErrorSource">
            <summary>
            The ErrorSource is the source block used for sending errors into the linked error flow.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowComponent.CancelComponent">
            <summary>
            Will cancel completion task for this component only.
            If you want to cancel the whole network, use Network.Cancel(..) instead
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.LogThreshold">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.ProgressCount">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowComponent.OnProgress">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowDestination`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowDestination`1.Wait">
            <summary>
            Waits for the completion of the component.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowDestination`1.LinkErrorTo(ETLBox.DataFlow.IDataFlowDestination{ETLBox.DataFlow.ETLBoxError})">
            <summary>
            If an error occurs in the component, by default the component will throw an exception and stop execution.
            If you use the error linking, any erroneous records will catched and redirected.
            </summary>
            <param name="target">The target for erroneous rows.</param>
            <returns>The linked component.</returns>
        </member>
        <member name="T:ETLBox.DataFlow.DataFlowExecutableSource`1">
            <summary>
            Base implementation for a source that can be executed.
            </summary>
            <typeparam name="TOutput"></typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowExecutableSource`1.Limit">
            <summary>
            Reads data from the source until the limit is reached. Default is 0 (=no limit).
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowExecutableSource`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowExecutableSource`1.Execute">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowExecutableSource`1.Post">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowExecutableSource`1.ExecuteAsync">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.DataFlowJoinTarget`1">
            <summary>
             A target block base implementation
            </summary>
            <typeparam name="TInput">Type of ingoing data</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowJoinTarget`1.TargetBlock">
            <summary>
            TargetBlock from the underlying TPL.Dataflow which is used as output buffer for the component.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.DataFlowSource`1">
            <summary>
            The base implementation for a source component.
            </summary>
            <typeparam name="TOutput">Type of outgoing data</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowSource`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowSource`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowSource`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowSource`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowSource`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowSource`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowSource`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlowSource`1.LinkErrorTo(ETLBox.DataFlow.IDataFlowDestination{ETLBox.DataFlow.ETLBoxError})">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.DataFlowStreamDestination`1">
            <summary>
            The base implementation for a destination that allows writing of data in a stream.
            </summary>
            <typeparam name="TInput">Type of ingoing data</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Uri">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.GetNextUri">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.HasNextUri">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.ResourceType">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.HttpClient">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.HttpRequestMessage">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Encoding">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.CreateStreamWriter">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.AzureBlobStorage">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.WriteUri">
            <summary>
            The Uri used for the current write operation- this will only be different to the <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Uri"/>
            if you use the <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.GetNextUri" /> and <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.HasNextUri"/> functions. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.StreamWriter">
            <summary>
            The stream writer used for the current request. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamDestination`1.HttpContentType">
            <summary>
            The content type used when sending the http request content. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.Uri">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.GetNextUri">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.HasNextUri">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.ResourceType">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.HttpClient">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.HttpRequestMessage">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.Encoding">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.UnparsedData">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.CreateStreamReader">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.AzureBlobStorage">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.SkipRows">
            <summary>
            Number of rows to skip before starting reading the header and csv data
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.RequestUri">
            <summary>
            The Uri used for the current request - this will only be different to the <see cref="P:ETLBox.DataFlow.DataFlowStreamSource`1.Uri"/>
            if you use the <see cref="P:ETLBox.DataFlow.DataFlowStreamSource`1.GetNextUri" /> and <see cref="P:ETLBox.DataFlow.DataFlowStreamSource`1.HasNextUri"/> functions. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowStreamSource`1.StreamReader">
            <summary>
            The stream reader used for the current request. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlowTransformation`2.TargetBlock">
            <summary>
            TargetBlock from the underlying TPL.Dataflow which is used as input buffer for the component.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.ConcurrentMemoryDestination`1">
            <summary>
            A destination in memory - it will store all data in a BlockingCollection&lt;T&gt;
            The BlockingCollection&lt;T&gt; allows you to access the data concurrently while rows are still written into the target.
            If you don't need to work with your data before the flow finishes, you can use
            the <see cref="T:ETLBox.DataFlow.Connectors.MemoryDestination"/> which uses a regular List&lt;T&gt;.
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.ConcurrentMemoryDestination">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomBatchDestination`1">
            <summary>
            Define your own batch destination block. 
            This block accepts all data from the flow and will create batches of incoming data
            which can be processed with the WriteBatchAction.
            </summary>  
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomBatchDestination`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomBatchDestination`1.WriteBatchAction">
            <summary>
            Each row that the CustomDestination receives is send into this Action as first input value. The second input value is the current progress count.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomBatchDestination">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomBatchDestination.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomBatchDestination.#ctor(System.Action{System.Dynamic.ExpandoObject[],System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomBatchDestination.#ctor(System.Int32,System.Action{System.Dynamic.ExpandoObject[],System.Int32})">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomBatchSource`1">
            <summary>
            Define your own source block. This block allows you to read batches of data from your own custom written functions,
            which are then send subsequently into your data flow. 
            </summary>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomBatchSource`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomBatchSource`1.ReadBatchFunc">
            <summary>
            The function that returns a batch of data row as output. An integer value with the
            current progress count is the input of the function.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomBatchSource`1.ReadingCompleted">
            <summary>
            This predicate returns true when all rows for the flow are successfully returned from the <see cref="P:ETLBox.DataFlow.Connectors.CustomBatchSource`1.ReadBatchFunc"/>. An integer value with the
            current progress count is the input of the predicate.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomBatchSource`1.#ctor(System.Func{System.Int32,System.Collections.Generic.IEnumerable{`0}},System.Predicate{System.Int32})">
            <param name="readBatchFunc">Sets the <see cref="P:ETLBox.DataFlow.Connectors.CustomBatchSource`1.ReadBatchFunc"/></param>
            <param name="readingCompleted">Sets the <see cref="P:ETLBox.DataFlow.Connectors.CustomBatchSource`1.ReadingCompleted"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomBatchSource">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomDestination`1">
            <summary>
            Define your own destination block. This block accepts all data from the flow and sends each incoming row to your custom Action, along with a count of processed rows. 
            </summary>
            <example>
            <code>
            List&lt;MyRow&gt; rows = new List&lt;MyRow&gt;();
            var dest = new CustomDestination&lt;MyRow&gt;();
            dest.WriteAction = (row, progressCount) => rows.Add(row);
            </code>
            </example>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomDestination`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomDestination`1.WriteAction">
            <summary>
            Each row that the CustomDestination receives is send into this Action as first input value. The second input value is the current progress count.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomDestination`1.#ctor(System.Action{`0,System.Int32})">
            <param name="writeAction">Sets the <see cref="P:ETLBox.DataFlow.Connectors.CustomDestination`1.WriteAction"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomDestination">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomDestination.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomDestination.#ctor(System.Action{System.Dynamic.ExpandoObject,System.Int32})">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomSource`1">
            <summary>
            Define your own source block. This block generates data from a your own custom written functions.
            </summary>
            <example>
            <code>
             List&lt;string&gt; Data = new List&lt;string&gt;()
             {
                 "Test1", "Test2", "Test3"
             };
             var source = new CustomSource&lt;MyRow&gt;();
             source.ReadFunc = progressCount =&gt;
             {
                 return new MyRow()
                 {
                     Id = progressCount + 1,
                     Value = Data[progressCount]
                 };    
                return result;
             };
            source.ReadCompletedFunc =  progressCount =&gt; progressCount &gt;= Data.Count;
            </code>
            </example>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomSource`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomSource`1.ReadFunc">
            <summary>
            The function that returns a data row as output. An integer value with the
            current progress count is the input of the function.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.CustomSource`1.ReadingCompleted">
            <summary>
            This predicate returns true when all rows for the flow are successfully returned from the <see cref="P:ETLBox.DataFlow.Connectors.CustomSource`1.ReadFunc"/>. An integer value with the
            current progress count is the input of the predicate.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.CustomSource`1.#ctor(System.Func{System.Int32,`0},System.Predicate{System.Int32})">
            <param name="readFunc">Sets the <see cref="P:ETLBox.DataFlow.Connectors.CustomSource`1.ReadFunc"/></param>
            <param name="readingCompleted">Sets the <see cref="P:ETLBox.DataFlow.Connectors.CustomSource`1.ReadingCompleted"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.CustomSource">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.DbDestination`1">
            <summary>
            A DbDestination represents a database table where ingoing data from the flow is written into.
            Inserts are done in batches (using Bulk insert or an equivalent INSERT statement).
            </summary>
            <typeparam name="TInput">Data type for ingoing data, preferably representing the data type for the destination table.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.DestinationTableDefinition">
            <summary>
            The table definition of the destination table. By default, the table definition is read from the database.
            Provide a table definition if the definition of the target can't be read automatically or you want the DbDestination
            only to use the columns in the provided definition.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.TableName">
            <summary>
            Name of the database table that receives the data from the data flow.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.BulkInsertConnectionManager">
            <summary>
            The connection manager used for the bulk inserts. This is a copy of the provided connection
            manager.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.ColumnMapping">
            <summary>
            Column mapping to map property to column names.
            E.g. if the value of property "Id" should be written into the database column "Key",
            then you can simply add a column mapping: DbColumnName: "Id" -> PropertyName: "Key".        
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.AllowIdentityInsert">
            <summary>
            By default, identity columns (a.k.a auto increment or serial columns) are ignored
            when writing into the destination. If set to true, the DbDestination will try to overwrite
            identity values (if there is a corresponding property with a new id value in the data object)
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.ColumnConverters">
            <summary>
            Use a column converter to apply a conversion function to each value of a column.
            </summary>
        </member>
        <member name="F:ETLBox.DataFlow.Connectors.DbDestination`1.DEFAULT_BATCH_SIZE_ODBC_OLEDB">
            <summary>
            The default batch sized used for ODBC or OleDb connections. Only use if BatchSize is not set manually.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbDestination`1.ConnectionManager">
            <summary>
            The connection manager used to connect to the database - use the right connection manager for your database type.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.DbDestination`1.#ctor(System.String)">
            <param name="tableName">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbDestination`1.TableName" /></param>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.DbDestination`1.#ctor(ETLBox.Connection.IConnectionManager,System.String)">
            <param name="connectionManager">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbDestination`1.ConnectionManager" /></param>
            <param name="tableName">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbDestination`1.TableName" /></param>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.DbDestination`1.#ctor(System.String,System.Int32)">
            <param name="tableName">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbDestination`1.TableName" /></param>
            <param name="batchSize">Sets the <see cref="P:ETLBox.DataFlow.DataFlowBatchDestination`1.BatchSize" /></param>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.DbDestination`1.#ctor(ETLBox.Connection.IConnectionManager,System.String,System.Int32)">
            <param name="connectionManager">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbDestination`1.ConnectionManager" /></param>
            <param name="tableName">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbDestination`1.TableName" /></param>
            <param name="batchSize">Sets the <see cref="P:ETLBox.DataFlow.DataFlowBatchDestination`1.BatchSize" /></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.DbDestination">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.DbMerge`1">
            <summary>
            Inserts, updates and (optionally) deletes data in database target.
            Before the Merge is executed, all data from the destination is read into memory.
            A delta table is generated that stores information if a records was inserted, updated, deleted or hasn't been touched (existed).
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.MergeMode">
            <summary>
            Defines the type of target data which affects how deletions or insertions are handled.
            Full means that source contains all data, NoDeletions that source contains all data but no deletions are executed,
            Delta means that source has only delta information and deletions are deferred from a particular property and
            OnlyUpdates means that only updates are applied to the destination.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.DestinationTableDefinition">
            <summary>
            The table definition of the destination table. By default, the table definition is read from the database.
            Provide a table definition if the definition of the target can't be read automatically or you want the DbMerge
            only to use the columns in the provided definition.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.ColumnMapping">
            <summary>
            Column mapping to map property to column names.
            E.g. if the value of property "Id" should be written into the database column "Key",
            then you can simply add a column mapping: DbColumnName: "Id" -> PropertyName: "Key".        
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.TableName">
            <summary>
            The name of the target database table for the merge.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.MergeProperties">
            <summary>
            A list of property names that are used in the Merge.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.UseTruncateMethod">
            <summary>
            By default, the deletion of records are performed with a bulk delete. 
            This performs well if the number of records to delete is small compared to the total amount 
            of records. 
            If this property is set to true, all records are deleted *before* the merge operation,
            using a TRUNCATE. Subsequently, all records are reinserted again. 
            In order to make this work, the <see cref="P:ETLBox.DataFlow.Connectors.DbMerge`1.MergeMode"/> needs to be set to Full
            and the <see cref="P:ETLBox.DataFlow.Connectors.DbMerge`1.CacheMode"/> set to Full as well. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.BatchSize">
            <summary>
            The batch size used when inserted data into the database table.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.CacheMode">
            <summary>
            The cache mode used for reading data from the destination table.
            By default, all data is read into memory before the actual merge is executed (Full mode).
            If set to partial, only data is read into memory that is needed for the current merge comparison.
            This will keep the memory consumption of the DbMerge much smaller. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.FindDuplicates">
            <summary>
            If set to true, the DbMerge will store already processed input data additionally in an internal lookup table.
            If another records with the same id arrives in this component, this record is then identified as a duplicate 
            and will be treated as update instead (the default is that the DbMerge would try to insert both records, 
            which likely results in an exception).
            Please note that this will heavenly increase memory consumption as all of your input data is additionally stored in a dictionary 
            before it is inserted into the destination. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbMerge`1.ConnectionManager">
            <summary>
            The connection manager used to connect to the database - use the right connection manager for your database type.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.DbSource`1">
            <summary>
            A database source defines either a table or sql query that returns data from a database.
            Multiple database are supported. Use the corresponding connection manager that fits to your database.
            </summary>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
            <example>
            <code>
            SqlConnectionManager connMan = new SqlConnectionManager("Data Source=localhost");
            DbSource&lt;MyRow&gt; source = new DbSource&lt;MyRow&gt;(connMan, "dbo.table");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.SourceTableDefinition">
            <summary>
            Pass a table definition that describe the source data.
            Only the column name needs to be provided - you can leave out other information.
            If you provide the <see cref="P:ETLBox.DataFlow.Connectors.DbSource`1.TableName"/>, ETLBox will try to read the table definition directly from the database.
            If you provide your own TableDefinition, this will always be used. 
            If you provide a <see cref="P:ETLBox.DataFlow.Connectors.DbSource`1.Sql"/> statement, ETLBox will try to automatically 
            read the column names from the sql query. Sometimes the automatic parsing from the query doesn't work.
            Then you can provide a TableDefinition which contains the column names in the same order
            as they appear in the sql statement. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.ColumnMapping">
            <summary>
            Column mapping to map column names to properties. 
            E.g. if the value of column "Key" should be written into the property "Id",
            then you can simply add a column mapping: DbColumnName: "Key" -> PropertyName: "Id".        
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.ColumnConverters">
            <summary>
            Use a column converter to apply custom conversion function to the data of a column.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.TableName">
            <summary>
            The name of the database table to read data from.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.Sql">
            <summary>
            A custom sql query to extract the data from the source.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.SqlParameter">
            <summary>
            List of query parameters that are used to replace values in <see cref="P:ETLBox.DataFlow.Connectors.DbSource`1.Sql"/>
            For every parameter provided, your sql statement should contain a placeholder.
            E.g.: 'SELECT col1 FROM table WHERE col2 > @parameter1'
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.DbSource`1.ConnectionManager">
            <summary>
            The connection manager used to connect to the database - use the right connection manager for your database type.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.DbSource`1.#ctor(System.String)">
            <param name="tableName">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbSource`1.TableName" /></param>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.DbSource`1.#ctor(ETLBox.Connection.IConnectionManager)">
            <param name="connectionManager">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbSource`1.ConnectionManager" /></param>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.DbSource`1.#ctor(ETLBox.Connection.IConnectionManager,System.String)">
            <param name="connectionManager">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbSource`1.ConnectionManager" /></param>
            <param name="tableName">Sets the <see cref="P:ETLBox.DataFlow.Connectors.DbSource`1.TableName" /></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.DbSource">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.MemoryDestination`1">
            <summary>
            A destination in memory - it will store all data in a collection
            that you assign to the Data property. By default, a List is used to store th data. 
            If you need to access the data concurrently while rows are still written into the target,
            see the <see cref="T:ETLBox.DataFlow.Connectors.ConcurrentMemoryDestination"/>.
            </summary>
            <example>
            <code>
            MemoryDestination&lt;MySimpleRow&gt; dest = new MemoryDestination&lt;MySimpleRow&gt;();
            //data is accessible in dest.Data         
            </code>
            </example>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.MemoryDestination`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.MemoryDestination`1.Data">
            <summary>
            The generic List&lt;T&gt; that will store all rows of incoming data in memory.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.MemoryDestination">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.MemorySource`1">
            <summary>
            Define a source based on a generic .NET collection. This could be a List&lt;T&gt; or any other IEnumerable&lt;T&gt;.
            By default, an empty List&lt;T&gt; is created which can be filled with data.
            </summary>
            <example>
            <code>
            MemorySource&lt;MyRow&gt; source = new MemorySource&lt;MyRow&gt;();
            source.Data = new List&lt;MyRow&gt;()
            {
                new MyRow() { Id = 1, Value = "Test1" },
                new MyRow() { Id = 2, Value = "Test2" },
                new MyRow() { Id = 3, Value = "Test3" }
            };
            </code>
            </example>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.MemorySource`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.MemorySource`1.Data">
            <summary>
            The .NET collection that is used to read the data from.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.MemorySource`1.DataAsList">
            <summary>
            If the source collection implements IList&lt;T&gt; then this property will convert the collection into this interface type.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.MemorySource`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <param name="data">Set the source collection and stores it in <see cref="P:ETLBox.DataFlow.Connectors.MemorySource`1.Data"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.MemorySource">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.TextDestination`1">
            <summary>
            Writes data into a text file. Each line in the output is created by calling the
            <see cref="P:ETLBox.DataFlow.Connectors.TextDestination`1.WriteLineFunc"/> or by invoking ToString() on the object.
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.TextDestination`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.TextDestination`1.WriteLineFunc">
            <summary>
            Defines how each row from the input is written into the file.
            The input for the Func is an object of the ingoing data type and return a string that is written into the target.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.TextDestination`1.WriteHeaderFunc">
            <summary>
            Before any rows are processed, the output of this 
            function is written at the beginning of the output file. 
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.TextDestination`1.#ctor">
            <summary>
            The default <see cref="T:ETLBox.DataFlow.ResourceType"/> for a TextDestination is a file.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.TextDestination`1.#ctor(System.String)">
            <param name="filename">Will set the <see cref="T:System.Uri"/> to the given file name.</param>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.TextDestination`1.#ctor(System.String,System.Func{`0,System.String})">
            <param name="filename">Will set the <see cref="T:System.Uri"/> to the given file name.</param>
            <param name="writeLineFunc">Sets the <see cref="P:ETLBox.DataFlow.Connectors.TextDestination`1.WriteLineFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.TextDestination">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.TextSource`1">
            <summary>
            Reads data from a text file.
            Each line is read as a string and converted into an object by the <see cref="P:ETLBox.DataFlow.Connectors.TextSource`1.ParseLineFunc"/>.
            A line is defined as a sequence of characters followed by a line feed("\n"), a carriage return ("\r"),
            or a carriage return immediately followed by a line feed("\r\n").
            </summary>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.TextSource`1.TaskName">
            <inheritdoc />
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.TextSource`1.ParseLineFunc">
            <summary>
            This Function is called for every line in the source document.
            The input is the current read line as as string and the current progress count. 
            The return value is the new row that is send into the connected components.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.TextSource`1.#ctor(System.String)">
            <param name="uri">The source of the file. This can be a filename or a web url.<see cref="T:System.Uri"/></param>
        </member>
        <member name="M:ETLBox.DataFlow.Connectors.TextSource`1.#ctor(System.String,System.Func{System.String,System.Int32,`0})">
            <param name="uri">The source of the file. This can be a filename or a web url.<see cref="T:System.Uri"/></param>
            <param name="parseLineFunc"><see cref="P:ETLBox.DataFlow.Connectors.TextSource`1.ParseLineFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.TextSource">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.VoidDestination`1">
            <summary>
            This destination serves as a recycle bin for data that is not supposed to go into any other destination.
            Every records in the dataflow needs to enter any kind of destination in order to have a dataflow completed.
            Use this target for data that you don't want to use in a destination, but you still want your dataflow to complete property.
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Connectors.VoidDestination`1.TaskName">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Connectors.VoidDestination">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.DataFlow">
            <summary>
            Contains static information which affects all Dataflow tasks in ETLBox.
            Here you can set the threshold value when information about processed records should appear.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.DataFlow.LogThreshold">
            <summary>
            To avoid getting a log message for every row, by default only a log message each 1000 rows. 
            Setting this property will decrease or increase this default value for all dataflow components.
            The individual log threshold can be overwritten in each component separately.
            </summary>
        </member>
        <member name="F:ETLBox.DataFlow.DataFlow.DEFAULT_LOG_THRESHOLD">
            <summary>
            The default value for <see cref="P:ETLBox.DataFlow.DataFlow.LogThreshold"/>
            </summary>        
        </member>
        <member name="P:ETLBox.DataFlow.DataFlow.MaxBufferSize">
            <summary>
            The default maximum size for all buffers in the dataflow.
            This is the default value. Each maximum buffer size value can overwritten in a dataflow component seperately.
            </summary>
        </member>
        <member name="F:ETLBox.DataFlow.DataFlow.DEFAULT_MAX_BUFFER_SIZE">
            <summary>
            The default value for <see cref="P:ETLBox.DataFlow.DataFlow.MaxBufferSize"/>
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.DataFlow.ClearSettings">
            <summary>
            Set all settings back to default values.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.JoinTarget`1">
            <summary>
            A target block that serves as a destination for components that can have multiple inputs.
            </summary>
            <typeparam name="TInput">Type of ingoing data</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.JoinTarget`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.AzureBlobStorageConfiguration">
            <summary>
            Contains configuration details to connect with an Azure Blob Storage
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.BlobClientOptions">
            <summary>
            Optional: Additional options when connecting with the <see cref="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.BlockBlobClient"/>
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.BlockBlobOpenWriteOptions">
            <summary>
            Optional: Additional options when opening the stream for writing
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.BlobOpenReadOptions">
            <summary>
            Optional: Additional options when opening the stream for reading
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.BlockBlobClient">
            <summary>
            Provide an existing BlockBlobClient to connect with Azure Blob Storage
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.StorageSharedKeyCredential">
            <summary>
            Token to authenticate when connecting to the blob Url provided in the <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Uri"/>
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.AzureSasCredential">
            <summary>
            Credentials to authenticate when connecting to the blob Url provided in the <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Uri"/>
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.TokenCredential">
            <summary>
            Token credential to authenticate when connecting to the blob Url provided in the <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Uri"/>
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.ConnectionString">
            <summary>
            Provide a connection string to the Azure Blob Storage. The <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Uri"/> needs to be the blob name,
            and <see cref="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.ContainerName" /> needs to have a value. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.ContainerName">
            <summary>
            Provide a container name in which the blob is created. The <see cref="P:ETLBox.DataFlow.DataFlowStreamDestination`1.Uri"/> needs to be the blob name,
            and <see cref="P:ETLBox.DataFlow.AzureBlobStorageConfiguration.ConnectionString" /> needs to have a value. 
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.ChangeAction">
            <summary>
            When comparing two data sets regarding their changes, this enumeration describe how they are different-
            Exists: Both are equal, Insert: This record is inserted, Update: This record is updated, Delete: This record is deleted.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.ErrorSource">
            <summary>
            Works as a source component for any errors. Another component
            can use this source to redirect errors into the error data flow.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.ErrorSource.Redirection">
            <summary>
            If set to another error source, all message send to this source will redirected.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.ErrorSource.LetErrorSourceWaitForInput">
            Called from DataFlowComponent - after network init the error source are
            startet with manual completion
        </member>
        <member name="M:ETLBox.DataFlow.ErrorSource.LetErrorSourceFinishUp">
            This is called when a component completes
        </member>
        <member name="M:ETLBox.DataFlow.ErrorSource.Send(System.Exception,System.String)">
            <summary>
            Sends the error message into the error data flow
            </summary>
            <param name="e">The exception message</param>
            <param name="jsonRow">The serialized erroneous row</param>
        </member>
        <member name="M:ETLBox.DataFlow.ErrorSource.ConvertErrorData``1(``0)">
            <summary>
            Serialized a row using the default json serialization
            </summary>
            <typeparam name="T">Type of the row</typeparam>
            <param name="row">The errorneous row</param>
            <returns>The faulty row serialized as json or "null" if input is null</returns>
        </member>
        <member name="T:ETLBox.DataFlow.ETLBoxError">
            <summary>
            The generic ETLBox Exception. Contains serialized information about the error.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.ETLBoxError.ErrorText">
            <summary>
            The exceptions message as string
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.ETLBoxError.ReportTime">
            <summary>
            The point in time when the error occured
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.ETLBoxError.ExceptionType">
            <summary>
            The exception type as string
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.ETLBoxError.RecordAsJson">
            <summary>
            The erroneous records serialized as json
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.MergeableRow">
            <summary>
            Inherit from this class if you want to use your data object with a DBMerge,
            but don't want to implement <see cref="T:ETLBox.DataFlow.IMergeableRow" /> yourself.
            You still needs that you have flagged the id properties with the IdColumn attribute
            and the properties use to identify equal object flagged with the UpdateColumn attribute.
            </summary>
            <see cref="T:ETLBox.DataFlow.UpdateColumn"/>
            <see cref="T:ETLBox.DataFlow.IdColumn"/>
        </member>
        <member name="P:ETLBox.DataFlow.MergeableRow.ChangeDate">
            <summary>
            Date and time when the object was considered for merging.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.MergeableRow.ChangeAction">
            <summary>
            The result of a merge operation - this is either 'I' for Insertion,
            'U' for Updates, 'E' for existing records (no change), and 'D' for deleted records.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.MergeMode">
            <summary>
            The mode of operation a DbMerge may work in.
            Full means that source contains all data, NoDeletions that source contains all data but no deletions are executed,
            Delta means that source has only delta information and deletions are deferred from a particular property and
            OnlyUpdates means that only updates are applied to the destination.
            InsertsOnly will only insert new rows into the destination.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.MergeProperties">
            <summary>
            A list of properties that describe on which the DbMerge can perform which merge operation.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.MergeProperties.IdColumns">
            <summary>
            Property names that are used to check if the columns match (id values are equal).
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.MergeProperties.CompareColumns">
            <summary>
            Property names that should be use to compare if the values of a column are equal, so that
            the DbMerge can decide if the column needs to be updated.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.MergeProperties.UpdateColumns">
            <summary>
            Property names that describe which columns are actually updated (if an update of the row is necessary).
            Can be left empty, then all non id columns will be updated. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.MergeProperties.DeleteColumns">
            <summary>
            List of property names and a to-be value that tells the DbMerge if this row can be deleted.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.MergeProperties.ChangeActionPropertyName">
            <summary>
            The property name where the ChangeAction is stored. Must by of type <see cref="T:ETLBox.DataFlow.ChangeAction"/>
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.MergeProperties.ChangeDatePropertyName">
            <summary>
            The property name where the date of the change is stored. Must be of type DateTime.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.StreamMetaData">
            <summary>
            This class holds meta data about the current progress of the source.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.StreamMetaData.ProgressCount">
            <summary>
            Number of currently processed items
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.StreamMetaData.ProcessedRows">
            <summary>
            Amounts of rows processed in the last request
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.StreamMetaData.UnparsedData">
            <summary>
            Unparsed meta data from the response. E.g. this could be unparsed json that holds the links to the next page of the response.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowComponent.Completion">
            <summary>
            The completion task of the component. A component is completed when all predecessors (if any) are
            completed and the current component has completed its buffer.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowComponent.OnCompletion">
            <summary>
            When a component has completed and processed all rows, the OnCompletion action is executed.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowComponent.Exception">
            <summary>
            If a component encountered an exception or entered a fault state because another component
            in the data flow faulted, the thrown exception will be stored in this property.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowComponent.MaxBufferSize">
            <summary>
            Each component can have one or more buffers to improve throughput and allow faster processing of data.
            Set this value to restrict the number of rows that can be stored in the buffer.
            The default value is -1 (unlimited)
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowDestination.Predecessors">
            <summary>
            All predecessors that are linked to this component.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowDestination`1.TargetBlock">
            <summary>
            TargetBlock from the underlying TPL.Dataflow which is used as output buffer for the component.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowBatchDestination.BatchSize">
            <summary>
            Batch size that is used when inserted data in batches
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowStreamDestination">
            <summary>
            Implemented by data flow destinations that allow writing data in a stream
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination.Uri">
            <summary>
            The Url of the webservice (e.g. https://test.com/foo) or the file name (relative or absolute)
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination.ResourceType">
            <summary>
            Specifies the resource type. 
            Use ResourceType.File if you want to write into a file (default)
            Use ResourceType.Http to write into a web endpoint.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination.HttpClient">
            <summary>
            The System.Net.HttpClient used to connect with the destination (only needed when the <see cref="P:ETLBox.DataFlow.IDataFlowStreamDestination.ResourceType"/> is Http.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination.HttpRequestMessage">
            <summary>
            The System.Net.Http.HttpRequestMessage use for the request from the HttpClient. You can use the 
            to add additional meta data or to change the request type (default is POST). 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination.Encoding">
            <summary>
            Encoding used to write data into the source file or web request.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination.CreateStreamWriter">
            <summary>
            By default, stream are created internally based on Uri &amp; ResourceType.
            If you already have an existing stream, use this function to returns a new StreamWriter based on this stream. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination.AzureBlobStorage">
            <summary>
            Use this to pass your AzureBlobStorage connection information. 
            There are different methods to connect with Azure Blob Storage:
            Option 1: provide an existing BlockBlobClient
            Option 2: create BlockBlobClient based on the Uri and optional credential tokens - the <see cref="P:ETLBox.DataFlow.IDataFlowStreamDestination.Uri"/> needs to be the blob url 
            Option 3: create BlobkBlobClient with provided ConnectionString and ContainerName, the <see cref="P:ETLBox.DataFlow.IDataFlowStreamDestination.Uri"/> is then the name of the blob
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowStreamDestination`1">
            <summary>
            Implemented by data flow destinations that allow writing data in a stream
            </summary>
            <typeparam name="TInput">Type of ingoing data</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination`1.GetNextUri">
            <summary>
            This function returns the next url that is used for writing data. It will used until <see cref="P:ETLBox.DataFlow.IDataFlowStreamDestination`1.HasNextUri"/> returns false.
            The incoming <see cref="T:ETLBox.DataFlow.StreamMetaData"/> holds information about the current progress and currently processed data row. 
            This property can be used if you want to write into multiple files or send data into different web services. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamDestination`1.HasNextUri">
            <summary>
            This func determines if the next data record should be written into another location. 
            <see cref="T:ETLBox.DataFlow.StreamMetaData"/> has information about the current progress and currently processed data row. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowLogging.ProgressCount">
            <summary>
            The amount of rows the current component has already processed.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowLogging.OnProgress">
            <summary>
            This delegate is invoked each time the progress counter changes
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowLogging.LogThreshold">
            <summary>
            To avoid getting log message for every message, by default only log message are produced when 1000 rows
            are processed. Set this property to decrease or increase this value.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowSource">
            <summary>
            Shared properties of all source components
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowSource.ErrorSource">
            <summary>
            The ErrorSource is the source block used for sending errors into the linked error flow.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowSource.Successors">
            <summary>
            All successors that this component is linked to.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowSource`1">
            <summary>
            Shared methods for linking of source components
            </summary>
            <typeparam name="TOutput">Type of outgoing data</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowSource`1.SourceBlock">
            <summary>
            SourceBlock from the underlying TPL.Dataflow which is used as output buffer for the component.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowSource`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0})">
            <summary>
            Links the current block to another transformation or destination.
            Every component should be linked to only one component without predicates
            If you want to link multiple targets, either use predicates or a <see cref="T:ETLBox.DataFlow.Transformations.Multicast"/>
            </summary>
            <param name="target">Transformation or destination that the block is linked to.</param>
            <returns>The linked component.</returns>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowSource`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0})">
            <summary>
            Links the current block to another transformation or destination with a predicate.
            Every component can be linked to one or more component. If you link multiple components,
            provide a <see cref="T:System.Predicate`1"/> that describe which row is send to which target.
            Make sure that all rows will be send to a target - use the <see cref="T:ETLBox.DataFlow.Connectors.VoidDestination"/>
            if you want to discarded rows.
            </summary>
            <param name="target">Transformation or destination that the block is linked to.</param>
            <param name="rowsToKeep">Only rows that evaluate to true are send to the connected target</param>
            <returns>The linked component.</returns>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowSource`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0},System.Predicate{`0})">
            <summary>
            Links the current block to another transformation or destination with a predicate for rows that you want to keep
            and a second predicate for rows you want to discard.
            </summary>
            <param name="target">Transformation or destination that the block is linked to.</param>
            <param name="rowsToKeep">Only rows that evaluate to true are send to the connected target</param>
            <param name="rowsIntoVoid">Rows that are evaluate to true will be discarded</param>
            <returns>The linked component.</returns>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowSource`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0})">
            <summary>
            Links the current block to another transformation or destination.
            Every component should be linked to only one component without predicates
            If you want to link multiple targets, either use predicates or a <see cref="T:ETLBox.DataFlow.Transformations.Multicast"/>
            </summary>
            <typeparam name="TConvert">Will convert the output type of the linked component.</typeparam>
            <param name="target">Transformation or destination that the block is linked to.</param>
            <returns>The linked component.</returns>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowSource`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0})">
            <summary>
            Links the current block to another transformation or destination with a predicate.
            Every component can be linked to one or more component. If you link multiple components,
            provide a <see cref="T:System.Predicate`1"/> that describe which row is send to which target.
            Make sure that all rows will be send to a target - use the <see cref="T:ETLBox.DataFlow.Connectors.VoidDestination"/>
            if you want to discarded rows.
            </summary>
            <typeparam name="TConvert">Will convert the output type of the linked component.</typeparam>
            <param name="target">Transformation or destination that the block is linked to.</param>
            <param name="rowsToKeep">Predicate - only rows that evaluate to true are send to the connected target</param>        
            <returns>The linked component.</returns>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowSource`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0},System.Predicate{`0})">
            <summary>
            Links the current block to another transformation or destination with a predicate for rows that you want to keep
            and a second predicate for rows you want to discard.
            </summary>
            <typeparam name="TConvert">Will convert the output type of the linked component.</typeparam>
            <param name="target">Transformation or destination that the block is linked to.</param>
            <param name="rowsToKeep">Only rows that evaluate to true are send to the connected target</param>
            <param name="rowsIntoVoid">Rows that are evaluate to true will be discarded</param>
            <returns>The linked component.</returns>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowSource`1.LinkErrorTo(ETLBox.DataFlow.IDataFlowDestination{ETLBox.DataFlow.ETLBoxError})">
            <summary>
            If an error occurs in the component, by default the component will throw an exception and stop execution.
            If you use the error linking, any erroneous records will be caught and redirected.
            </summary>
            <param name="target">The target for erroneous rows.</param>
            <returns>The linked component.</returns>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowExecutableSource">
            <summary>
            Shared methods for sources that can be executed
            </summary>    
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowExecutableSource.Execute">
            <summary>
            Starts the data flow for all connected components (also for other sources in the network).
            Waits until all destinations run to completion. 
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowExecutableSource.Post">
            <summary>
            Starts the data flow synchronously. This method will return when all data was posted into the flow
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.IDataFlowExecutableSource.ExecuteAsync">
            <summary>
            Starts the data flow asynchronously. This method will return an awaitable task that completes or faults when the flow ran to completion.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowExecutableSource`1">
            <summary>
            Shared methods for sources that can be executed
            </summary>
            <typeparam name="TOutput">Type of outgoing data</typeparam>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowStreamSource">
            <summary>
            Implemented by data flow sources that allow reading data from a stream source
            </summary>    
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.Uri">
            <summary>
            The Url of the webservice (e.g. https://test.com/foo) or the file name (relative or absolute).
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.GetNextUri">
            <summary>
            This function returns the next url that is used for reading data. It will be called until <see cref="P:ETLBox.DataFlow.IDataFlowStreamSource.HasNextUri"/> returns false.
            The incoming <see cref="T:ETLBox.DataFlow.StreamMetaData"/> holds information about the current progress and other meta data from the response, like unparsed
            json data that contains references to the next page of the response.
            This property can be used if you want to read multiple files or if you want to paginate through web responses.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.HasNextUri">
            <summary>
            This func determines if another request is started to read additional data from the next uri.
            <see cref="T:ETLBox.DataFlow.StreamMetaData"/> has information about the current progress and other meta data from the response.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.ResourceType">
            <summary>
            Specifies the resource type. By default requests are made with HttpClient.
            Specify ResourceType.File if you want to read from a json file.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.HttpClient">
            <summary>
            The System.Net.Http.HttpClient uses for the request. Use this client if you want to
            add or change the http request data, e.g. you can add your authorization information here.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.HttpRequestMessage">
            <summary>
            The System.Net.Http.HttpRequestMessage use for the request from the HttpClient. Add your request
            message here, e.g. your POST body.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.CreateStreamReader">
            <summary>
            By default, stream are created internally based on Uri &amp; ResourceType.
            If you already have an existing stream, use this function to returns a StreamReader based on this stream. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.Encoding">
            <summary>
            Encoding used to read data from the source file or web request. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.UnparsedData">
            <summary>
            Contains all data from the stream that couldn't be processed. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IDataFlowStreamSource.AzureBlobStorage">
            <summary>
            Use this to pass your AzureBlobStorage connection information. 
            There are different methods to connect with Azure Blob Storage:
            Option 1: provide an existing BlockBlobClient
            Option 2: create BlockBlobClient based on the Uri and optional credential tokens - the <see cref="P:ETLBox.DataFlow.IDataFlowStreamSource.Uri"/> needs to be the blob url 
            Option 3: create BlockBlobClient with provided ConnectionString and ContainerName, the <see cref="P:ETLBox.DataFlow.IDataFlowStreamSource.Uri"/> is then the name of the blob
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowStreamSource`1">
            <summary>
            Implemented by data flow sources that allow reading data from a stream source    
            </summary>
            <typeparam name="TOutput">Type of outgoing data</typeparam>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowTransformation`2">
            <summary>
            Implemented by transformations that have one or more inputs of the same type and one or more outputs of the same type
            </summary>
            <typeparam name="TInput">Type of ingoing data</typeparam>
            <typeparam name="TOutput">Type of outgoing data</typeparam>
        </member>
        <member name="T:ETLBox.DataFlow.IDataFlowTransformation`1">
            <summary>
            Implemented by transformations that can have multiple inputs with different type and one or more outputs of the same type
            </summary>
            <typeparam name="TOutput">Type of outgoing data</typeparam>
        </member>
        <member name="T:ETLBox.DataFlow.IMergeableRow">
            <summary>
            Represents table row in destination database when inserting data using <see cref="T:ETLBox.DataFlow.Connectors.DbMerge`1"/>
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.IMergeableRow.ChangeDate">
            <summary>
            Time when the object was considered for merging
            </summary>
            <remarks>
            When <see cref="P:ETLBox.DataFlow.IMergeableRow.ChangeAction"/> is set, this value is set to <see cref="P:System.DateTime.Now"/>
            </remarks>
            <value>null means not determined yet</value>
        </member>
        <member name="P:ETLBox.DataFlow.IMergeableRow.ChangeAction">
            <summary>
            The result of a merge operation
            </summary>        
            <value>null means not determined yet</value>
        </member>
        <member name="T:ETLBox.DataFlow.Network">
            <summary>
            The network class allows you execute, monitor and cancel data flows.
            You need to provide at least one start node to run the network. All other linked components
            will be retrieved automatically. If you provide more nodes, the algorithm will determine if 
            a network has already started or not and ignore the other nodes. 
            It is recommend to pass only one node from the network. 
            </summary>
            <example>
            <code>
            Network.Execute(source1); 
            
            Network.Execute(source1, source2); //If source1 and source2 are in the same network, providing source2 is superflous
            
            Task t = Network.ExecuteAsync(dest1);
            t.Wait();
            </code>
            </example>
        </member>
        <member name="M:ETLBox.DataFlow.Network.ExecuteAsync">
            <summary>
            Will execute the data flow for the whole network asynchronously. 
            The network is derived from the given <see cref="P:ETLBox.DataFlow.Network.StartNodes"/> (only one node of the network is needed)
            </summary>
            <returns>A task that is ran to completion when the whole network is completed.</returns>
        </member>
        <member name="M:ETLBox.DataFlow.Network.Execute">
            <summary>
            Will execute the data flow for the whole network synchronously. 
            The network is derived from the given <see cref="P:ETLBox.DataFlow.Network.StartNodes"/> (only one node of the network is needed)
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Network.ExecuteAsync(ETLBox.DataFlow.DataFlowComponent[])">
            <summary>
            Will execute the data flow for the whole network asynchronously. 
            </summary>
            <param name="startNodes">At least one node in the network that should be executed
            - can by any node in the network</param>
        </member>
        <member name="M:ETLBox.DataFlow.Network.Execute(ETLBox.DataFlow.DataFlowComponent[])">
            <summary>
            Will execute the data flow for the whole network synchronously. 
            </summary>
            <param name="startNodes">At least one node in the network that should be executed
            - can by any node in the network</param>
        </member>
        <member name="M:ETLBox.DataFlow.Network.Cancel">
            <summary>
            Cancel the BufferCompletion(s) on all nodes in the network, will start cancelation from the sources.
            This will result in all nodes canceled in the whole network. 
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Network.Cancel(ETLBox.DataFlow.DataFlowComponent[])">
            <summary>
            Cancel the BufferCompletion(s) on all nodes in the network, will start cancelation from the sources.
            This will result in all nodes canceled in the whole network. 
            </summary>
            <param name="startNodes">The start nodes - only one node in the whole network is sufficient</param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.Aggregation`2">
            <summary>
            Aggregates data by the given aggregation methods.
            The aggregate is a partial-blocking transformation - only the aggregation values are stored in separate memory objects.
            When all rows have been processed by the aggregation, the aggregated values are written into the output.
            </summary>
            <example>
            <code>
            public class MyDetailValue
            {
                public int DetailValue { get; set; }
            }
            
            public class MyAggRow
            {
                [AggregateColumn(nameof(MyDetailValue.DetailValue), AggregationMethod.Sum)]
                public int AggValue { get; set; }
            }
            
            var source = new DbSource&lt;MyDetailValue&gt;("DetailValues");
            var agg = new Aggregation&lt;MyDetailValue, MyAggRow&gt;();
            var dest = new MemoryDestination&lt;MyAggRow&gt;();
            source.LinkTo&lt;MyAggRow&gt;(agg).LinkTo(dest);
            </code>
            </example>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.AggregationAction">
            <summary>
            This action describes how the input data is aggregated.
            Not needed if you use the <see cref="T:ETLBox.DataFlow.AggregateColumn" /> in your object
            or pass a list to the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.AggregateColumns" /> property. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.GroupingFunc">
            <summary>
            This Func defines how the object for grouping data is retrieved.
            Not needed if you use the <see cref="T:ETLBox.DataFlow.GroupColumn" /> in your object
            or pass a list to the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.GroupColumns" /> property. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.StoreKeyAction">
            <summary>
            This action defines how the grouping object is written back into the aggregated object.
            Not needed if you use the <see cref="T:ETLBox.DataFlow.GroupColumn" /> in your object
            or pass a list to the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.GroupColumns" /> property. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.AggregateColumns">
            <summary>
            This list will be used to set the AggregationAction.
            This also works with ExpandoObjects.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Aggregation`2.GroupColumns">
            <summary>
            This list will be used to set the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.GroupingFunc"/> and the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.StoreKeyAction" />.
            This also works with ExpandoObjects.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.Aggregation`2.#ctor(System.Action{`0,`1})">
            <param name="aggregationAction">Sets the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.AggregationAction"/></param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.Aggregation`2.#ctor(System.Action{`0,`1},System.Func{`0,System.Object})">
            <param name="aggregationAction">Sets the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.AggregationAction"/></param>
            <param name="groupingFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.GroupingFunc"/></param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.Aggregation`2.#ctor(System.Action{`0,`1},System.Func{`0,System.Object},System.Action{System.Object,`1})">
            <param name="aggregationAction">Sets the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.AggregationAction"/></param>
            <param name="groupingFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.GroupingFunc"/></param>
            <param name="storeKeyAction">Sets the <see cref="P:ETLBox.DataFlow.Transformations.Aggregation`2.StoreKeyAction"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.Aggregation">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.BatchTransformation`2">
            <summary>
            A batch transformation will transform batches of data. The default batch size are 100000 rows. 
            The batch transformation function allows you to process and modify each batch of data. 
            You can use the BatchSize property to choose a smaller batch size. The batch size must always be smaller
            than the max buffer size. The default batch size are 1000 rows per batch.
            The batch transformation is a partial blocking transformation - it will always need at least enough
            memory to store a whole batch. 
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>    
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.BatchTransformationFunc">
            <summary>
            The transformation Func that is executed on each array of input data. It returns
            another array as output data - the output array can have a different length than
            the input array. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.BatchSize">
            <summary>
            The size of each batch that is passed to the <see cref="T:ETLBox.DataFlow.Transformations.BatchTransformation`2"/>
            Default is 1000.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.InitAction">
            <summary>
            The init action is executed shortly before the first data row is processed.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.SuppressNullValueFilter">
            <summary>
            By default, all null values in the batch returned from the batch transformation func
            are filtered out. Set this option to true to avoid this behavior.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.BatchTransformation`2.#ctor(System.Int32)">
            <param name="batchSize">The size of each batch</param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.BatchTransformation`2.#ctor(System.Int32,System.Func{`0[],`1[]})">
            <param name="batchSize">The size of each batch</param>
            <param name="batchTransformationFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.BatchTransformation`2.BatchTransformationFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.BatchTransformation`1">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.BatchTransformation">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.BlockTransformation`2">
            <summary>
            A block transformation will wait for all data from the flow to be loaded into its buffer.
            After all data is in the buffer, the transformation function
            is executed for the complete data and the result posted into the targets.
            The block transformations allows you to access all data in the flow in one generic collection.
            But as this block any processing until all data is buffered, it will also need to store the whole data in memory.
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
            <example>
            <code>
            BlockTransformation&lt;InputType&gt; block = new BlockTransformation&lt;InputType&gt;(
                inputData => {
                    inputData.RemoveRange(1, 2);
                    inputData.Add(new InputType() { Value = 1 });
                    return inputData;
            });
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BlockTransformation`2.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BlockTransformation`2.BatchSize">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BlockTransformation`2.MaxBufferSize">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.BlockTransformation`2.BlockTransformationFunc">
            <summary>
            The transformation Func that is executed on the complete input data. It needs
            to return an array of output data, which doesn't need have to be the same length
            as the input array. 
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.BlockTransformation`2.#ctor(System.Func{`0[],`1[]})">
            <param name="blockTransformationFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.BlockTransformation`2.BlockTransformationFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.BlockTransformation`1">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.BlockTransformation">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3">
            <summary>
            A batch transformation will transform batches of data. The default batch size are 100000 rows. 
            The batch transformation function allows you to process and modify each batch of data. 
            You can use the BatchSize property to choose a smaller batch size. The batch size must always be smaller
            than the max buffer size. The default batch size are 1000 rows per batch.
            The batch transformation is a partial blocking transformation - it will always need at least enough
            memory to store a whole batch. 
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>    
            <typeparam name="TCache">Type of data in the cache.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3.CacheManager">
            <summary>
            The CacheManager to use when caching data
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3.MaxCacheSize">
            <summary>
            The maximum amount of previously records to store
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3.FillCacheAfterTranformation">
            <summary>
            If set to true, the incoming row will be added to the cache after the 
            transformation func has been invoked. 
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3.#ctor(System.Int32)">
            <param name="batchSize">The size of each batch</param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3.#ctor(System.Int32,System.Func{`0[],System.Collections.Generic.ICollection{`2},`1[]})">
            <param name="batchSize">The size of each batch</param>
            <param name="batchTransformationFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.CachedBatchTransformation`3.BatchTransformationFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CachedBatchTransformation`2">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CachedBatchTransformation`1">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedRowTransformation`3.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedRowTransformation`3.CacheManager">
            <summary>
            The CacheManager used for caching data
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedRowTransformation`3.MaxCacheSize">
            <summary>
            The maximum amount of previously records to store
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CachedRowTransformation`3.FillCacheAfterTranformation">
            <summary>
            If set to true, the incoming row will be added to the cache after the 
            transformation func has been invoked. 
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.CachedRowTransformation`3.#ctor(System.Func{`0,System.Collections.Generic.ICollection{`2},`1})">
            <param name="transformationFunc">Will set the <see cref="P:ETLBox.DataFlow.Transformations.CachedRowTransformation`3.TransformationFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CachedRowTransformation`2">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CachedRowTransformation`1">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CachedRowTransformation">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.ColumnRename`1">
            <summary>
            ColumnRename allows you to rename the column or properties names of your ingoing data. 
            This transformation works with objects, ExpandoObjects and arrays as input data type.    
            ColumnRename will always convert the input type into a (dynamic) ExpandoObject. 
            Provide a column mapping with the old and the new name. The mapping can also be automatically retrieved from 
            existing ColumnMap attributes. For arrays provide the array index and the new name. 
            </summary>
            <typeparam name="TInput">Type of ingoing data</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.ColumnRename`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.ColumnRename`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.ColumnRename`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.ColumnRename`1.RenameColumns">
            <summary>
            The column mapping defines how existing properties or columns are renamed. 
            For objects and dynamic object provide a mapping with the old and the new name (arrays: array index and new name).
            The mapping can also be automatically retrieved from <see cref="T:ETLBox.DataFlow.RenameColumn"/> attributes on the properties in strongly typed objects.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.ColumnRename`1.RenameFunc">
            <summary>
            Instead (or additional) to existing column renaming provided via the <see cref="P:ETLBox.DataFlow.Transformations.ColumnRename`1.RenameColumns"/> property or 
            the <see cref="T:ETLBox.DataFlow.RenameColumn"/> attribute, you can define your own renaming function.
            It is called for each column in each row from the input, and allows you to transform the column/property name into
            a different property name. 
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.ColumnRename">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CrossJoin`3">
            <summary>
            The CrossJoin allows you to combine every record from one input with every record from the other input.
            The input for the first table will be loaded into memory before join starts. 
            Then every incoming row will be joined with every row of the InMemory-Table using the CrossJoinFunc function.
            The InMemory target should always be the target of the smaller amount of data to reduce memory consumption and processing time.
            </summary>
            <typeparam name="TInput1">Type of data for in memory input block.</typeparam>
            <typeparam name="TInput2">Type of data for processing input block.</typeparam>
            <typeparam name="TOutput">Type of output data.</typeparam>
            <example>
            <code>
            CrossJoin&lt;InputType1, InputType2, OutputType&gt; crossJoin = new CrossJoin&lt;InputType1, InputType2, OutputType&gt;();
            crossJoin.CrossJoinFunc = (inmemoryRow, passingRow) => {
                return new OutputType() {
                    Result = leftRow.Value1 + rightRow.Value2
                };
            });
            source1.LinkTo(join.InMemoryTarget);
            source2.LinkTo(join.PassingTarget);
            join.LinkTo(dest);
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CrossJoin`3.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CrossJoin`3.InMemoryTarget">
            <summary>
            The in-memory target of the CrossJoin. This will block processing until all data is received that is designated for this target.
            Always have the smaller amount of data flown into this target.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CrossJoin`3.PassingTarget">
            <summary>
            Every row that the PassingTarget receives is joined with all data from the <see cref="P:ETLBox.DataFlow.Transformations.CrossJoin`3.InMemoryData"/>.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CrossJoin`3.CrossJoinFunc">
            <summary>
            The cross join function that describes how records from the both target can be joined.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.CrossJoin`3.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.CrossJoin`3.#ctor(System.Func{`0,`1,`2})">
            <param name="crossJoinFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.CrossJoin`3.CrossJoinFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CrossJoin`1">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.CrossJoin">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Distinct`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Distinct`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Distinct`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Distinct`1.DistinctColumns">
            <summary>
            Defines the property names that should be used to determine
            the uniqueness of an object. 
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.FilterTransformation`1">
            <summary>
            The FilterTransformation allows you to filter out rows that evaluate to a given predicate. 
            By default the filter transformation will filter out null values. 
            </summary>
            <typeparam name="TInput">The type of ingoing data.</typeparam>    
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.FilterTransformation`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.FilterTransformation`1.FilterPredicate">
            <summary>
            The filter predicates is true for all rows that should be filtered out. The default value will filter out null values. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.FilterTransformation`1.TargetBlock">
            <inheritdoc />
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.FilterTransformation`1.SourceBlock">
            <inheritdoc />
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.FilterTransformation`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.FilterTransformation`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.FilterTransformation`1.LinkTo(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.FilterTransformation`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.FilterTransformation`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.FilterTransformation`1.LinkTo``1(ETLBox.DataFlow.IDataFlowDestination{`0},System.Predicate{`0},System.Predicate{`0})">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.FilterTransformation`1.LinkErrorTo(ETLBox.DataFlow.IDataFlowDestination{ETLBox.DataFlow.ETLBoxError})">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.FilterTransformation">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.LookupTransformation`2">
            <summary>
            The lookup transformation enriches the incoming data with data from the lookup source.
            Data from the lookup source is read into memory when the first record arrives.
            For each incoming row, the lookup tries to find a matching record in the 
            loaded source data and uses this record to enrich the ingoing data.
            </summary>
            <example>
            <code>
            public class Order
            {    
                public int OrderNumber { get; set; }
                public int CustomerId { get; set; }
                public string CustomerName { get; set; }
            }
            
            public class Customer
            {
                [RetrieveColumn(nameof(Order.CustomerId))]
                public int Id { get; set; }
            
                [MatchColumn(nameof(Order.CustomerName))]
                public string Name { get; set; }
            }
            
            DbSource&lt;Order&gt; orderSource = new DbSource&lt;Order&gt;("OrderData");
            CsvSource&lt;Customer&gt; lookupSource = new CsvSource&lt;Customer&gt;("CustomerData.csv");
            var lookup = new LookupTransformation&lt;Order, Customer&gt;();
            lookup.Source = lookupSource;
            DbDestination&lt;Order&gt; dest = new DbDestination&lt;Order&gt;("OrderWithCustomerTable");
            source.LinkTo(lookup).LinkTo(dest);
            </code>
            </example>
            <typeparam name="TInput">Type of ingoing and outgoing data.</typeparam>
            <typeparam name="TSource">Type of data used in the lookup source.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.SourceRecords">
            <summary>
            Holds the data read from the lookup source. This data is used to find data that is missing in the incoming rows.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.SourceRecordsByKey">
            <summary>
            Holds a dictionary containing data from the lookup spurce. 
            The dictionary key is generated using the <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.GetSourceRecordKeyFunc"/>
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.Source">
            <summary>
            The source component from which the lookup data is retrieved. E.g. a <see cref="T:ETLBox.DataFlow.Connectors.DbSource"/> or a <see cref="T:ETLBox.DataFlow.Connectors.MemorySource"/>.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.RetrievalFunc">
            <summary>
            The retrieval function that describes how the ingoing data can be enriched with the already pre-read data from
            the <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.Source"/>.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.RetrievalByKeyFunc">
            <summary>
            The retrieval function that describes how the ingoing data can be enriched with the already pre-read data from
            - this one returns not only a list, but a dictionary that provides faster access to the data. The dictionary
            key is created with the GetSourceKeyFunc.
            the <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.Source"/>.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.GetSourceRecordKeyFunc">
            <summary>
            This function describe how the key is generated for a row from the lookup source.
            This key is used to store the data in the lookup dictionary. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.GetInputRecordKeyFunc">
            <summary>
            This function describe how the key is generated for an ingoing row.
            If the result of this function match with <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.GetSourceRecordKeyFunc"/>,
            both records can be identified as a match. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.UseExactNumericTypes">
            <summary>
            If set to true, data types are ignored when comparing data to identify matching records.
            E.g. property that stores the integer value 7 would match with a string "7". 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.MatchColumns">
            <summary>
            This collection will be used to define the matching columns - will also work with ExpandoObject.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.RetrieveColumns">
            <summary>
            This collection will be used to define the retrieve columns - will also work with ExpandoObject.
            </summary>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.LookupTransformation`2.PartialDbCacheSettings">
            <summary>
            Defines properties to configure a partial cache in a Lookup.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.PartialDbCacheSettings.LoadCacheSql">
            <summary>
            A custom sql to load data from the lookup source based on the input batch. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.PartialDbCacheSettings.ClearCache">
            <summary>
            Default is true. The lookup cache is cleared after every batch
            of incoming data. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.PartialDbCacheSettings.LoadBatchSize">
            <summary>
            The cache is filled not for every row, but for a batch of rows to improve throughput.
            Define here the number of rows for every batch. 
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.CacheMode">
            <summary>
            The cache mode used for loading data into the lookup cache.
            By default, all data is loaded into memory from the lookup source when the first
            records arrives at the lookup.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.PartialCacheSettings">
            <summary>
            Only need if you set the <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.CacheMode"/> to PartialDbCache.
            This will only work if you use a <see cref="T:ETLBox.DataFlow.Connectors.DbSource"/> as lookup source.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.LookupTransformation`2.#ctor(ETLBox.DataFlow.IDataFlowExecutableSource{`1})">
            <param name="source">Sets the <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.Source"/> of the lookup.</param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.LookupTransformation`2.#ctor(ETLBox.DataFlow.IDataFlowExecutableSource{`1},System.Func{`0,System.Collections.Generic.ICollection{`1},`0})">
            <param name="source">Sets the <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.Source"/> of the lookup.</param>
            <param name="retrievalFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.LookupTransformation`2.RetrievalFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.LookupTransformation">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.MergeJoin`3">
             <summary>
             Will join data from the two inputs into one output. Make sure both inputs are sorted or in the right order.
             Each row from the left join target will be merged with a row from the right join target.
             If the amount of ingoing data is unevenly distributed, the last rows will be joined with null values.
            
             You can define a match condition that let you only merge matching records. This will change the
             match behavior a little bit.
             By assuming that the input is sorted, not matching records will be joined with null then. This
             can be compared with a left or right join.
             </summary>
             <typeparam name="TInput1">Type of ingoing data for the left join target.</typeparam>
             <typeparam name="TInput2">Type of ingoing data for the right join target.</typeparam>
             <typeparam name="TOutput">Type of outgoing data.</typeparam>
             <example>
             <code>
             MergeJoin&lt;InputType1, InputType2, OutputType&gt; join = new MergeJoin&lt;InputType1, InputType2, OutputType&gt;();
             join.MergeJoinFunc =  (leftRow, rightRow) => {
                 return new OutputType()
                 {
                     Result = leftRow.Value 1 + rightRow.Value2
                 };
             });
             source1.LinkTo(join.LeftInput);
             source2.LinkTo(join.RightInput);
             join.LinkTo(dest);
             </code>
             </example>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.MergeJoin`3.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.MergeJoin`3.LeftInput">
            <summary>
            The left target of the merge join. Use this to link your source component with.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.MergeJoin`3.RightInput">
            <summary>
            The right target of the merge join. Use this to link your source component with.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.MergeJoin`3.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.MergeJoin`3.MergeJoinFunc">
            <summary>
            The func that describes how both records from the left and right join target can be joined.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.MergeJoin`3.ComparisonFunc">
            <summary>
            If the ComparisonFunc is defined, records are compared regarding their sort order and only joined if they match. 
            Return 0 if both records match and should be joined. 
            Return a value little than 0 if the record of the left input is in the sort order before the record of the right input.
            Return a value greater than 0 if the record for the right input is in the order before the record from the left input.
            </summary>
            <remarks>Make sure that both inputs are sorted, and the comparison func take the sort order into account.</remarks>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.MergeJoin`3.#ctor(System.Func{`0,`1,`2})">
            <param name="mergeJoinFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.MergeJoin`3.MergeJoinFunc"/></param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.MergeJoin`3.#ctor(System.Func{`0,`1,`2},System.Func{`0,`1,System.Int32})">
            <param name="mergeJoinFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.MergeJoin`3.MergeJoinFunc"/></param>
            <param name="comparisonFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.MergeJoin`3.ComparisonFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.MergeJoin`1">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.MergeJoin">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.Multicast`1">
            <summary>
            A multicast broadcast data from the input into two or more outputs.
            Every linked component will receive a copy of the rows that the Multicast receives.
            There is no limit how many target the Multicast can be linked to.
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
            <example>
            <code>
            Multicast&lt;MyDataRow&gt; multicast = new Multicast&lt;MyDataRow&gt;();
            multicast.LinkTo(dest1);
            multicast.LinkTo(dest2);
            multicast.LinkTo(dest3);
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Multicast`1.TaskName">
            <inheritdoc />
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Multicast`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Multicast`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.Multicast">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowDuplication`1">
            <summary>
            Creates one or more duplicates of your incoming row. Use the CanDuplicate 
            property if you want to duplicate only particular rows.
            </summary>
            <example>
            <code>
            var source = new DbSource&lt;InputType&gt;("SourceTable");
            RowDuplication&lt;InputType&gt; duplication = new RowDuplication&lt;InputType&gt;(3);
            var dest = new CsvDestination&lt;InputType&gt;("output.csv");
            source.LinkTo(duplication).LinkTo(dest);
            </code>
            </example>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowDuplication`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowDuplication`1.NumberOfDuplicates">
            <summary>
            Number of duplicates to be created for each ingoing row.
            Default is 1 (meaning the incoming row plus one copy).
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowDuplication`1.CanDuplicate">
            <summary>
            A predicate that describe if a will be duplicated or not.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowDuplication`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowDuplication`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.RowDuplication`1.#ctor(System.Int32)">
            <param name="numberOfDuplicates">Sets the <see cref="P:ETLBox.DataFlow.Transformations.RowDuplication`1.NumberOfDuplicates"/></param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.RowDuplication`1.#ctor(System.Predicate{`0},System.Int32)">
            <param name="canDuplicate">Sets the <see cref="P:ETLBox.DataFlow.Transformations.RowDuplication`1.CanDuplicate"/> predicate</param>
            <param name="numberOfDuplicates">Sets the <see cref="P:ETLBox.DataFlow.Transformations.RowDuplication`1.NumberOfDuplicates"/></param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.RowDuplication`1.#ctor(System.Predicate{`0})">
            <param name="canDuplicate">Sets the <see cref="P:ETLBox.DataFlow.Transformations.RowDuplication`1.CanDuplicate"/> predicate</param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowDuplication">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowMultiplication`2">
            <summary>
            This transformation allow you to transform one row of your input data into multiple rows.
            </summary>
            <typeparam name="TInput">Type of ingoing data.</typeparam>
            <typeparam name="TOutput">Type of outgoing data.</typeparam>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowMultiplication`2.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowMultiplication`2.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowMultiplication`2.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowMultiplication`2.MultiplicationFunc">
            <summary>
            The transformation func that produces multiple rows for each ingoing row.
            </summary>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.RowMultiplication`2.#ctor(System.Func{`0,System.Collections.Generic.IEnumerable{`1}})">
            <param name="multiplicationFunc">Sets the <see cref="P:ETLBox.DataFlow.Transformations.RowMultiplication`2.MultiplicationFunc"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowMultiplication">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowMultiplication`1">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowTransformation`2">
            <summary>
            The RowTransformation will apply the transformation function to each row of data.
            </summary>
            <typeparam name="TInput">The type of ingoing data.</typeparam>
            <typeparam name="TOutput">The type of outgoing data.</typeparam>
            <see cref="T:ETLBox.DataFlow.Transformations.RowTransformation"/>
            <example>
            <code>
            RowTransformation&lt;InputType, OutputType&gt; trans = new RowTransformation&lt;InputType, OutputType&gt;(
            row => {
                return new OutputType() { Value = row.Value + 1 };
            });
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowTransformation`2.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowTransformation`2.TransformationFunc">
            <summary>
            Each ingoing row will be transformed using this function.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowTransformation`2.InitAction">
            <summary>
            The init action is executed shortly before the first data row is processed.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowTransformation`2.TargetBlock">
            <inheritdoc />
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.RowTransformation`2.SourceBlock">
            <inheritdoc />
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.RowTransformation`2.#ctor(System.Func{`0,`1})">
            <param name="transformationFunc">Will set the <see cref="P:ETLBox.DataFlow.Transformations.RowTransformation`2.TransformationFunc"/></param>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.RowTransformation`2.#ctor(System.Func{`0,`1},System.Action)">
            <param name="transformationFunc">Will set the <see cref="P:ETLBox.DataFlow.Transformations.RowTransformation`2.TransformationFunc"/></param>
            <param name="initAction">Will set the <see cref="P:ETLBox.DataFlow.Transformations.RowTransformation`2.InitAction"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowTransformation`1">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.RowTransformation">
            <inheritdoc />
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.Sort`1">
            <summary>
            Sorts the incoming data with by the given comparison function.
            This is a blocking transformation - no output will be produced until all input data has arrived in the transformation.
            </summary>
            <typeparam name="TInput">Type of ingoing (and also outgoing) data.</typeparam>
            <example>
            <code>
            Comparison&lt;MyDataRow&gt; comp = new Comparison&lt;MyDataRow&gt;(
                (x, y) => y.Value2 - x.Value2
            );
            Sort&lt;MyDataRow&gt; block = new Sort&lt;MyDataRow&gt;(comp);
            </code>
            </example>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Sort`1.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Sort`1.MaxBufferSize">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Sort`1.SortFunction">
            <summary>
            A System.Comparison used to sort the data.
            </summary>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Sort`1.SourceBlock">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.DataFlow.Transformations.Sort`1.TargetBlock">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.DataFlow.Transformations.Sort`1.#ctor(System.Comparison{`0})">
            <param name="sortFunction">Will set the <see cref="P:ETLBox.DataFlow.Transformations.Sort`1.SortFunction"/></param>
        </member>
        <member name="T:ETLBox.DataFlow.Transformations.Sort">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.DataFlow.ResourceType">
            <summary>
            The type of resource you are using for a streaming source or destination.
            E.g. you can read Json data from a file or via http from a web service.
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.ControlFlow">
            <summary>
            Contains static information which affects all ETLBox tasks and general logging behavior for all components.
            Here you can set default connections string, disbale the logging for all processes or set the current stage used in your logging configuration.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ControlFlow.DefaultDbConnection">
            <summary>
            You can store your general database connection string here. This connection will then used by all Tasks where no DB connection is excplicitly set.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.ControlFlow.ClearSettings">
            <summary>
            Set all settings back to default (which is null or false)
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.ProcedureDefinition">
            <summary>
            Defines a procedure
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureDefinition.Name">
            <summary>
            Name of the procedure
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureDefinition.Definition">
            <summary>
            The sql code of the procudure
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureDefinition.Parameter">
            <summary>
            List of parameters for the procedure
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.ProcedureParameter">
            <summary>
            A parameter used in a procedure
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureParameter.Name">
            <summary>
            Name of the procedure parameter
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureParameter.DataType">
            <summary>
            Sql data type of the procedure parameter
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureParameter.DefaultValue">
            <summary>
            The default value of the parameter
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureParameter.ReadOnly">
            <summary>
            Indicates that the parameter is read only
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ProcedureParameter.Out">
            <summary>
            Indicates that the parameter is used as output
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.QueryParameter">
            <summary>
            A parameter used in a query
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.QueryParameter.Name">
            <summary>
            Name of the parameter
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.QueryParameter.Type">
            <summary>
            The sql parameter type (e.g. "INT")
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.QueryParameter.Value">
            <summary>
            The value of the parameter
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.QueryParameter.DBType">
            <summary>
            The database type parsed from the parameter type
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.TableColumn">
            <summary>
            A column in table
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.Name">
            <summary>
            Name of the column
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.DataType">
            <summary>
            The sql data type of the column (e.g. "INT" or "VARCHAR(30)")
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.AllowNulls">
            <summary>
            True, if the column is nullable. By default a column is not nullable.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.IsIdentity">
             <summary>
             True, if the column is used as an Identity column (auto increment in MySql or serial in Postgres)
             Not every database supports this.
             </summary>
            
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.IsPrimaryKey">
            <summary>
            True if the column is part of the primary key
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.DefaultValue">
            <summary>
            Define a default value for the column.
            Not all databases may support this.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.Collation">
            <summary>
            The collation used for the column. Leave empty if you want to use the default collation.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.ComputedColumn">
            <summary>
            The calculation if the column should be computed.
            Not all databases may support this.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.NETDataType">
            <summary>
            The corresponding .NET data type retrieved from the sql <see cref="P:ETLBox.ControlFlow.TableColumn.DataType"/>.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.Comment">
            <summary>
            A comment for the column (not supported by every database)
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.IdentitySeed">
            <summary>
            Only SqlServer: The seed for and identity column
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableColumn.IdentityIncrement">
            <summary>
            Only SqlServer: The increment value for an identity column
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.TableData">
            <summary>
            Defines a list of rows that can be inserted into a table
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.ColumnMapping">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.CurrentRow">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.ReadIndex">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.Rows">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.DestinationTableName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetDataTypeName(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.DataIndexForColumn">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.Definition">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.AllowIdentityInsert">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetBoolean(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetByte(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetChar(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetDateTime(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetData(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetDecimal(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetDouble(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetFloat(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetGuid(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetInt16(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetInt32(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetInt64(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetString(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetFieldType(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetSchemaTable">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetValues(System.Object[])">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.Item(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.Depth">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.FieldCount">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.IsClosed">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.TableData.RecordsAffected">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetName(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetDataTypeName(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetOrdinal(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.GetValue(System.Int32)">
            <inheritdoc/>        
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.IsDBNull(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.NextResult">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.Read">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.Dispose">
            Disposes the internal list that holds data
        </member>
        <member name="M:ETLBox.ControlFlow.TableData.Close">
            Disposes the internal list that holds data
        </member>
        <member name="T:ETLBox.ControlFlow.TableDefinition">
            <summary>
            A definition for a table in a database
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableDefinition.Name">
            <summary>
            The name of the table
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableDefinition.Columns">
            <summary>
            The columns of the table
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.TableDefinition.PrimaryKeyConstraintName">
            <summary>
            The constraint name for the primary key
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.TableDefinition.CreateTable">
            <summary>
            Uses the CreateTableTask to create a table based on the current definition.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.TableDefinition.CreateTable(ETLBox.Connection.IConnectionManager)">
            <summary>
            Uses the CreateTableTask to create a table based on the current definition.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
        </member>
        <member name="M:ETLBox.ControlFlow.TableDefinition.FromTableName(ETLBox.Connection.IConnectionManager,System.String,System.Boolean)">
            <summary>
            Gather a table definition from an existing table in the database.
            </summary>
            <param name="connection">The connection manager of the database you want to connect</param>
            <param name="tableName">A name of an existing table in the database</param>
            <param name="readConstraints">If set to true, information about the Unique and Foreign Key constraints are also gathered.</param>
            <returns></returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask">
            <summary>
            Tries to remove all database objects from the given schema(s).
            Currently only SqlServer and Oracle support this task.
            </summary>
            <example>
            <code>
            CleanUpSchemaTask.CleanUp("demo");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.Execute">
            <summary>
            Runs the sql to clean up the schema
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.SchemaName">
            <summary>
            The name of the schema
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.Sql">
            <summary>
            The sql code that is used to clean up the schema.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.CleanUp">
            <summary>
            Runs the sql to clean up the user schema. (Oracle only)
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.CleanUp(ETLBox.Connection.IConnectionManager)">
            <summary>
            Runs the sql to clean up the user schema. (Oracle only)
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.CleanUp(System.String)">
            <summary>
            Runs the sql to clean up a schema. (Oracle and SqlServer only)
            </summary>
            <param name="schemaName">The name of the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CleanUpSchemaTask.CleanUp(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Runs the sql to clean up a schema.(Oracle and SqlServer only)
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">The name of the schema</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.CreateDatabaseTask">
            <summary>
            Will create a database if the database doesn't exists. In MySql or MariaDb, this will create a schema.
            </summary>
            <example>
            <code>
            CreateDatabaseTask.Create("DemoDB");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.Create">
            <summary>
            Runs the sql code to create the database.
            Throws an exception if the database already exists. 
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.CreateIfNotExists">
            <summary>
            Runs the sql code to create the database if the database doesn't exist yet.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.DatabaseName">
            <summary>
            The name of the database (In MySql: The schema name)
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.RecoveryModel">
            <summary>
            Sql Server only: The recovery model of the database
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.Collation">
            <summary>
            The default collation for the database
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.Sql">
            <summary>
            The sql code that is used to generate the database
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.Create(System.String)">
            <summary>
            Creates a database. In MySql or MariaDb, this will create a schema.
            Will throw an exception if the database already exists.
            Make sure that your default connection string points to the server itself and to an existing database (e.g. a system database).
            </summary>
            <param name="databaseName">The name of the database</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.Create(System.String,System.String)">
            <summary>
            Creates a database. In MySql or MariaDb, this will create a schema.
            Will throw an exception if the database already exists.
            Make sure that your default connection string points to the server itself and to an existing database (e.g. a system database).
            </summary>
            <param name="databaseName">The name of the database</param>
            <param name="collation">The default collation of the database.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.Create(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Creates a database. In MySql or MariaDb, this will create a schema.
            Will throw an exception if the database already exists.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect. Make sure this points to a database
            that does exist (e.g. a system database)</param>
            <param name="databaseName">The name of the database</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.Create(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Creates a database. In MySql or MariaDb, this will create a schema.
            Will throw an exception if the database already exists.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect. Make sure this points to a database
            that does exist (e.g. a system database)</param>
            <param name="databaseName">The name of the database</param>
            <param name="collation">The default collation of the database.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.CreateIfNotExists(System.String)">
            <summary>
            Creates a database if the database doesn't exists. In MySql or MariaDb, this will create a schema.
            Make sure that your default connection string points to the server itself and to an existing database (e.g. a system database).
            </summary>
            <param name="databaseName">The name of the database</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.CreateIfNotExists(System.String,System.String)">
            <summary>
            Creates a database if the database doesn't exists. In MySql or MariaDb, this will create a schema.
            Make sure that your default connection string points to the server itself and to an existing database (e.g. a system database).
            </summary>
            <param name="databaseName">The name of the database</param>
            <param name="collation">The default collation of the database.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.CreateIfNotExists(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Creates a database if the database doesn't exists. In MySql or MariaDb, this will create a schema.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect. Make sure this points to a database
            that does exist (e.g. a system database)</param>
            <param name="databaseName">The name of the database</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateDatabaseTask.CreateIfNotExists(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Creates a database if the database doesn't exists. In MySql or MariaDb, this will create a schema.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect. Make sure this points to a database
            that does exist (e.g. a system database)</param>
            <param name="databaseName">The name of the database</param>
            <param name="collation">The default collation of the database.</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.RecoveryModel">
            <summary>
            The sql server recovery models.
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.CreateIndexTask">
            <summary>
            Creates an index if the index doesn't exists, otherwise the index is dropped and recreated.
            </summary>
            <example>
            <code>
            CreateIndexTask.Create("indexname","tablename", indexColumns)
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.TaskName">
            <inheritdoc />
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateIndexTask.Execute">
            <summary>
            Runs the sql to (re)create the index on a table.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateIndexTask.CreateOrRecrate">
            <summary>
            Runs the sql to (re)create the index on a table.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.IndexName">
            <summary>
            The name of the index
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.IN">
            <summary>
            The formatted name of the index
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.TableName">
            <summary>
            The name of the table the index is based on.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.TN">
            <summary>
            The formatted name of the table.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.IndexColumns">
            <summary>
            A list of column names for the index
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.IncludeColumns">
            <summary>
            A list of included column names for the index.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.IsUnique">
            <summary>
            Set the index as Unique.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.IsClustered">
            <summary>
            Set the index as a clustered index
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateIndexTask.Sql">
            <summary>
            The sql code used to generate the index
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateIndexTask.CreateOrRecreate(System.String,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            Creates an index. If the index exists, it is dropped and recreated.
            </summary>
            <param name="indexName">The name of the index</param>
            <param name="tableName">The name of the table the index is based on</param>
            <param name="indexColumns">The name of the columns for the index</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateIndexTask.CreateOrRecreate(System.String,System.String,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
            <summary>
            Creates an index. If the index exists, it is dropped and recreated.
            </summary>
            <param name="indexName">The name of the index</param>
            <param name="tableName">The name of the table the index is based on</param>
            <param name="indexColumns">The name of the columns for the index</param>
            <param name="includeColumns">The name of the columns that are included in the index</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateIndexTask.CreateOrRecreate(ETLBox.Connection.IConnectionManager,System.String,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            Creates an index. If the index exists, it is dropped and recreated.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="indexName">The name of the index</param>
            <param name="tableName">The name of the table the index is based on</param>
            <param name="indexColumns">The name of the columns for the index</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateIndexTask.CreateOrRecreate(ETLBox.Connection.IConnectionManager,System.String,System.String,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{System.String})">
            <summary>
            Creates an index. If the index exists, it is dropped and recreated.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="indexName">The name of the index</param>
            <param name="tableName">The name of the table the index is based on</param>
            <param name="indexColumns">The name of the columns for the index</param>
            <param name="includeColumns">The name of the columns that are included in the index.</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.CreateProcedureTask">
            <summary>
            Creates or updates a procedure.
            </summary>
            <example>
            <code>
            CRUDProcedureTask.CreateOrAlter("demo.proc1", "select 1 as test");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateProcedureTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateProcedureTask.Execute">
            <summary>
            Creates or updates the procedure on the database if the database does support procedures.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateProcedureTask.ProcedureName">
            <summary>
            The name of the procedure
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateProcedureTask.PN">
            <summary>
            The formatted procedure name
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateProcedureTask.ProcedureDefinition">
            <summary>
            The sql code of the procedure
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateProcedureTask.ProcedureParameters">
            <summary>
            The parameters for the procedure
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateProcedureTask.Sql">
            <summary>
            The sql code that is used to create/update the procedure.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateProcedureTask.CreateOrAlter(System.String,System.String)">
            <summary>
            Creates or updates a procedure.
            </summary>
            <param name="procedureName">The name of the procedure</param>
            <param name="procedureDefinition">The sql code of the procedure</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateProcedureTask.CreateOrAlter(System.String,System.String,System.Collections.Generic.IList{ETLBox.ControlFlow.ProcedureParameter})">
            <summary>
            Creates or updates a procedure.
            </summary>
            <param name="procedureName">The name of the procedure</param>
            <param name="procedureDefinition">The sql code of the procedure</param>
            <param name="procedureParameter">A list of the parameters for the procedure</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateProcedureTask.CreateOrAlter(ETLBox.ControlFlow.ProcedureDefinition)">
            <summary>
            Creates or updates a procedure.
            </summary>
            <param name="procedure">The procedure definition object containing procedure name, code and potential parameters</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateProcedureTask.CreateOrAlter(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Creates or updates a procedure.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="procedureName">The name of the procedure</param>
            <param name="procedureDefinition">The sql code of the procedure</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateProcedureTask.CreateOrAlter(ETLBox.Connection.IConnectionManager,System.String,System.String,System.Collections.Generic.IList{ETLBox.ControlFlow.ProcedureParameter})">
            <summary>
            Creates or updates a procedure.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="procedureName">The name of the procedure</param>
            <param name="procedureDefinition">The sql code of the procedure</param>
            <param name="procedureParameter">A list of the parameters for the procedure</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateProcedureTask.CreateOrAlter(ETLBox.Connection.IConnectionManager,ETLBox.ControlFlow.ProcedureDefinition)">
            <summary>
            Creates or updates a procedure.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="procedure">The procedure definition object containing procedure name, code and potential parameters</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.CreateSchemaTask">
            <summary>
            Creates a schema. For MySql or MariaDb, use the CreateDatabaseTask instead.
            The Create method will throw an exception if the schema already exists. 
            CreateIfNotExists will only create a schema if it doesn't exists.
            </summary>
            <example>
            <code>
            CreateSchemaTask.Create("demo");
            CreateSchemaTask.CreateIfNotExists("demo2");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateSchemaTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateSchemaTask.SchemaName">
            <summary>
            The name of the schema
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.Create">
            <summary>
            Runs the sql that creates the schema. If the schema already exists, an Exception is thrown.
            Works only if the database does support schema (for MySql, use the CreateDatabaseTask instead)
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.CreateIfNotExists">
            <summary>
            Runs the sql that creates the schema. Schema is only created if the schema doesn't exists.
            Works only if the database does support schema (for MySql, use the CreateDatabaseTask instead)
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateSchemaTask.ON">
            <summary>
            The formatted schema name
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateSchemaTask.Sql">
            <summary>
            The sql that is used to create the schema.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.Create(System.String)">
            <summary>
            Creates a schema. Throws an exception if the schema already exists. For MySql, use the CreateDatabaseTask instead.
            </summary>
            <param name="schemaName">The name of the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.Create(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Creates a schema. Throws an exception if the schema already exists. For MySql, use the CreateDatabaseTask instead.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">The name of the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.CreateIfNotExists(System.String)">
            <summary>
            Creates a schema if the schema doesn't exists. For MySql, use the CreateDatabaseTask instead.
            </summary>
            <param name="schemaName">The name of the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.CreateIfNotExists(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Creates a schema if the schema doesn't exists. For MySql, use the CreateDatabaseTask instead
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">The name of the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.Create(System.String,System.String)">
            <summary>
            Creates a schema. Throws an exception if the schema already exists. For MySql, use the CreateDatabaseTask instead.
            </summary>
            <param name="schemaName">The name of the schema</param>
            <param name="authorizationUser">Database user which is authorized for the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.Create(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Creates a schema. Throws an exception if the schema already exists. For MySql, use the CreateDatabaseTask instead.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">The name of the schema</param>
            <param name="authorizationUser">Database user which is authorized for the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.CreateIfNotExists(System.String,System.String)">
            <summary>
            Creates a schema if the schema doesn't exists. For MySql, use the CreateDatabaseTask instead.
            </summary>
            <param name="schemaName">The name of the schema</param>
            <param name="authorizationUser">Database user which is authorized for the schema</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateSchemaTask.CreateIfNotExists(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Creates a schema if the schema doesn't exists. For MySql, use the CreateDatabaseTask instead
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">The name of the schema</param>
            <param name="authorizationUser">Database user which is authorized for the schema</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.CreateTableTask">
            <summary>
            Creates a table. If the tables exists, this task won't change the table.
            </summary>
            <example>
            <code>
            CreateTableTask.Create("demo.table1", new List&lt;TableColumn&gt;() {
            new TableColumn(name:"key", dataType:"int", allowNulls:false, isPrimaryKey:true, isIdentity:true),
                new TableColumn(name:"value", dataType:"nvarchar(100)", allowNulls:true)
            });
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.TaskName">
            <inheritdoc />
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.TableDefinition">
            <summary>
            The table definition for the table that should be created. Either use the TableDefinition or a combination of
            <see cref="P:ETLBox.ControlFlow.Tasks.CreateTableTask.TableName"/> and <see cref="T:ETLBox.ControlFlow.TableColumn"/>.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.TN">
            <summary>
            The formatted table name
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.Columns">
            <summary>
            The list of columns to create. Either use the <see cref="P:ETLBox.ControlFlow.Tasks.CreateTableTask.TableDefinition"/> or a combination of
            <see cref="P:ETLBox.ControlFlow.Tasks.CreateTableTask.TableName"/> and <see cref="T:ETLBox.ControlFlow.TableColumn"/>.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.TableName">
            <summary>
            The name of the table to create.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.DataTypeConverter">
            <summary>
            A data type converter that is used to remap the current data type names in the TableDefintion
            to other, database specific type names. E.g. you can remap that the type VARCHAR(8000) is created as TEXT.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.IgnoreCollation">
            <summary>
            When creating the CREATE TABLE sql, ignore the Collation definition that a <see cref="T:ETLBox.ControlFlow.TableColumn"/> potentially has.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateTableTask.Sql">
            <summary>
            The sql code that is used to create the table.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateIfNotExists">
            <summary>
            Executes the table creation if the table doesn't exist.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Create">
            <summary>
            Executes the table creation. Throws an exception if the table exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateOrAlter">
            <summary>
            Executes the table creation or execute the corresponding alter statements to adjust the table.
            If the table is empty, the new table is always dropped and recreated. 
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.AlterIfDifferent">
            <summary>
            Execute the alter statements to change the table
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Create(System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Creates a table using a CREATE TABLE statement.
            Throws an exception if the table already exists.
            </summary>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Create(ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Creates a table using a CREATE TABLE statement.
            Throws an exception if the table already exists.
            </summary>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Create(ETLBox.Connection.IConnectionManager,System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Creates a table  using a CREATE TABLE statement.
            Throws an exception if the table already exists.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Create(ETLBox.Connection.IConnectionManager,ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Creates a table using a CREATE TABLE statement.
            Throws an exception if the table already exists.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateIfNotExists(System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Creates a table using a CREATE TABLE statement if the table doesn't exist.
            </summary>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateIfNotExists(ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Creates a table using a CREATE TABLE statement if the table doesn't exist.
            </summary>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateIfNotExists(ETLBox.Connection.IConnectionManager,System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Creates a table using a CREATE TABLE statement if the table doesn't exist.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateIfNotExists(ETLBox.Connection.IConnectionManager,ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Creates a table using a CREATE TABLE statement if the table doesn't exist.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Alter(System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Alter(ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Alter(ETLBox.Connection.IConnectionManager,System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.Alter(ETLBox.Connection.IConnectionManager,ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.AlterIfNeeded(System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.AlterIfNeeded(ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.AlterIfNeeded(ETLBox.Connection.IConnectionManager,System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.AlterIfNeeded(ETLBox.Connection.IConnectionManager,ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Alters a table using ALTER TABLE statements.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateOrAlter(System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Creates a table if the table doesn't exist or alters a table using ALTER TABLE statements.
            If the table does not contain any rows, it will be dropped and created again. 
            </summary>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateOrAlter(ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Creates a table if the table doesn't exist or alters a table using ALTER TABLE statements.
            If the table does not contain any rows, it will be dropped and created again. 
            </summary>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateOrAlter(ETLBox.Connection.IConnectionManager,System.String,System.Collections.Generic.List{ETLBox.ControlFlow.TableColumn})">
            <summary>
            Creates a table if the table doesn't exist or alters a table using ALTER TABLE statements.
            If the table does not contain any rows, it will be dropped and created again. 
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableName">The name of the table</param>
            <param name="columns">The columns of the table</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateTableTask.CreateOrAlter(ETLBox.Connection.IConnectionManager,ETLBox.ControlFlow.TableDefinition)">
            <summary>
            Creates a table if the table doesn't exist or alters a table using ALTER TABLE statements.
            If the table does not contain any rows, it will be dropped and created again. 
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableDefinition">The definition of the table containing table name and columns.</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.CreateViewTask">
            <summary>
            Creates or alters a view.
            </summary>
            <example>
            <code>
            CreateViewTask.CreateOrAlter("viewname","SELECT value FROM table");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateViewTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateViewTask.Execute">
            <summary>
            Executes the creation/altering of the view.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateViewTask.ViewName">
            <summary>
            The name of the view
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateViewTask.VN">
            <summary>
            The formatted name of the view
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateViewTask.Definition">
            <summary>
            The view definition.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateViewTask.ViewAttributes">
            <summary>
            Optional, will set the view attributes, e.g. "WITH SCHEMABINDING".
            This part is put after the CREATE VIEW [viewname] statement 
            and before the AS statement.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.CreateViewTask.Sql">
            <summary>
            The sql that is generated to create the view
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateViewTask.CreateOrAlter(System.String,System.String)">
            <summary>
            Creates or alter a view.
            </summary>
            <param name="viewName">The name of the view</param>
            <param name="definition">The view definition</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.CreateViewTask.CreateOrAlter(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Creates or alter a view.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="viewName">The name of the view</param>
            <param name="definition">The view definition</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.DropDatabaseTask">
            <summary>
            Drops a database. Use DropIfExists to drop a database only if it exists. In MySql, this will drop a schema.
            </summary>
            <example>
            <code>
            DropDatabaseTask.Delete("DemoDB");
            </code>
            </example>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropDatabaseTask.Drop(System.String)">
            <summary>
            Drops a database. In MySql, this will drop a schema.
            Make sure that your default connection string points to the server itself and to an existing database (e.g. a system database).
            </summary>
            <param name="databaseName">Name of the database (MySql: schema) to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropDatabaseTask.Drop(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a database. In MySql, this will drop a schema.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect. Make sure this points to a database
            that does exist (e.g. a system database)</param>
            <param name="databaseName">Name of the database (MySql: schema) to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropDatabaseTask.DropIfExists(System.String)">
            <summary>
            Drops a database if the database exists. In MySql, this will drop a schema.
            </summary>
            <param name="databaseName">Name of the database (MySql: schema) to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropDatabaseTask.DropIfExists(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a database if the database exists. In MySql, this will drop a schema.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect. Make sure this points to a database
            that does exist (e.g. a system database)</param>
            <param name="databaseName">Name of the database (MySql: schema) to drop</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.DropIndexTask">
            <summary>
            Drops an index. Use DropIfExists to drop an index only if it exists.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.DropIndexTask.TableName">
            <summary>
            The table name on which the index is based on.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.DropIndexTask.TN">
            <summary>
            The formatted table name on which the index is based on.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropIndexTask.Drop(System.String,System.String)">
            <summary>
            Drops an index.
            </summary>
            <param name="indexName">The index name to drop.</param>
            <param name="tableName">The table name the index is based on.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropIndexTask.Drop(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Drops an index.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="indexName">The index name to drop.</param>
            <param name="tableName">The table name the index is based on.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropIndexTask.DropIfExists(System.String,System.String)">
            <summary>
            Drops an index if the index exists.
            </summary>
            <param name="indexName">The index name to drop.</param>
            <param name="tableName">The table name the index is based on.</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropIndexTask.DropIfExists(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            Drops an index if the index exists.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="indexName">The index name to drop.</param>
            <param name="tableName">The table name the index is based on.</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.DropProcedureTask">
            <summary>
            Drops a procedure. Use DropIfExists to drop a procedure only if it exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropProcedureTask.Drop(System.String)">
            <summary>
            Drops a procedure.
            </summary>
            <param name="procedureName">Name of the procedure to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropProcedureTask.Drop(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a procedure.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="procedureName">Name of the procedure to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropProcedureTask.DropIfExists(System.String)">
            <summary>
            Drops a procedure if the procedure exists.
            </summary>
            <param name="procedureName">Name of the procedure to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropProcedureTask.DropIfExists(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a procedure if the procedure exists.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="procedureName">Name of the procedure to drop</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.DropSchemaTask">
            <summary>
            Drops a schema. Use DropIfExists to drop a schema only if it exists. For MySql or MariaDb, use the DropDatabase task instead.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropSchemaTask.Drop(System.String)">
            <summary>
            Drops a schema. For MySql, use the DropDatabase task instead.
            </summary>
            <param name="schemaName">Name of the schema to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropSchemaTask.Drop(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a schema. For MySql, use the DropDatabase task instead.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">Name of the schema to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropSchemaTask.DropIfExists(System.String)">
            <summary>
            Drops a schema if the schema exists. For MySql, use the DropDatabase task instead.
            </summary>
            <param name="schemaName">Name of the schema to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropSchemaTask.DropIfExists(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a schema if the schema exists. For MySql, use the DropDatabase task instead.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">Name of the schema to drop</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.DropTableTask">
            <summary>
            Drops a table. Use DropIfExists to drop a table only if it exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropTableTask.Drop(System.String)">
            <summary>
            Drops a table.
            </summary>
            <param name="tableName">Name of the table to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropTableTask.Drop(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a table.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableName">Name of the table to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropTableTask.DropIfExists(System.String)">
            <summary>
            Drops a table if the table exists.
            </summary>
            <param name="tableName">Name of the table to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropTableTask.DropIfExists(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a table if the table exists.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="tableName">Name of the table to drop</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.DropViewTask">
            <summary>
            Drops a view. Use DropIfExists to drop a view only if it exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropViewTask.Drop(System.String)">
            <summary>
            Drops a view.
            </summary>
            <param name="viewName">Name of the view to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropViewTask.Drop(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a view
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="viewName">Name of the view to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropViewTask.DropIfExists(System.String)">
            <summary>
            Drops a view if the view exists.
            </summary>
            <param name="viewName">Name of the view to drop</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.DropViewTask.DropIfExists(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Drops a view if the view exists.
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="viewName">Name of the view to drop</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.GetDatabaseListTask">
            <summary>
            Returns a list of all user databases on the server. Make sure to connect with the correct permissions!
            In MySql, this will return a list of all schemas.
            </summary>
            <example>
            <code>
            GetDatabaseListTask.List();
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.GetDatabaseListTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.GetDatabaseListTask.ListAll">
            <summary>
            Runs sql code to determine all user database names.
            </summary>
            <returns>A list of all user database names</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.GetDatabaseListTask.ListAll(ETLBox.Connection.IConnectionManager)">
            <summary>
            Runs sql code to determine all user database names.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect</param>
            <returns>A list of all user database names</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.GetTableListTask">
            <summary>
            Returns a list of all tables in the currently connected database.     
            Make sure to connect with the correct permissions!
            </summary>
            <example>
            <code>    
            List&lt;ETLBox.Helper.ObjectNameDescriptor&gt; alltables = GetTableListTask.List();
            foreach (var on in alltables) {
                Console.WriteLine("Schema:" + on.UnquotatedSchemaName);
                Console.WriteLine("TableName:" + on.UnquotatedObjectName);
                Console.WriteLine("Full qualified name:" + on.QuotatedFullName);
            }
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.GetTableListTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.GetTableListTask.ListAll">
            <summary>
            Runs sql code to determine all user database names.
            </summary>
            <returns>A list of all user database names</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.GetTableListTask.ListAll(ETLBox.Connection.IConnectionManager)">
            <summary>
            Runs sql code to determine all user database names.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect</param>
            <returns>A list of all user database names</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.GetViewListTask">
            <summary>
            Returns a list of all tables in the currently connected database.     
            Make sure to connect with the correct permissions!
            </summary>
            <example>
            <code>    
            List&lt;ETLBox.Helper.ObjectNameDescriptor&gt; allviews = GetViewListTask.List();
            foreach (var on in allviews) {
                Console.WriteLine("Schema:" + on.UnquotatedSchemaName);
                Console.WriteLine("ViewName:" + on.UnquotatedObjectName);
                Console.WriteLine("Full qualified name:" + on.QuotatedFullName);
            }
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.GetViewListTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.GetViewListTask.ListAll">
            <summary>
            Runs sql code to determine all user database names.
            </summary>
            <returns>A list of all user database names</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.GetViewListTask.ListAll(ETLBox.Connection.IConnectionManager)">
            <summary>
            Runs sql code to determine all user database names.
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect</param>
            <returns>A list of all user database names</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.IfDatabaseExistsTask">
            <summary>
            Checks if a database exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfDatabaseExistsTask.IsExisting(System.String)">
            <summary>
            hecks if the database exists. Make sure that your default connection string points to the server itself and to an existing database.
            (E.g. a system database)
            </summary>
            <param name="databaseName">The database name that you want to check for existence</param>
            <returns>True if the database exists</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfDatabaseExistsTask.IsExisting(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            hecks if the database exists
            </summary>
            <param name="connectionManager">The connection manager of the server you want to connect. Make sure this points to a database
            that does exist (e.g. a system database)</param>
            <param name="databaseName">The database name that you want to check for existence</param>
            <returns>True if the procedure exists</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.IfIndexExistsTask">
            <summary>
            Checks if an index exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfIndexExistsTask.IsExisting(System.String,System.String)">
            <summary>
            hecks if the index exists
            </summary>
            <param name="indexName">The index name that you want to check for existence</param>
            <param name="tableName">The table name on which the index is based on</param>
            <returns>True if the index exists</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfIndexExistsTask.IsExisting(ETLBox.Connection.IConnectionManager,System.String,System.String)">
            <summary>
            hecks if the index exists
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="indexName">The index name that you want to check for existence</param>
            <param name="tableName">The table name on which the index is based on</param>
            <returns>True if the index exists</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.IfProcedureExistsTask">
            <summary>
            Checks if a procedure exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfProcedureExistsTask.IsExisting(System.String)">
            <summary>
            hecks if the procedure exists
            </summary>
            <param name="procedureName">The procedure name that you want to check for existence</param>
            <returns>True if the procedure exists</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfProcedureExistsTask.IsExisting(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            hecks if the procedure exists
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="procedureName">The procedure name that you want to check for existence</param>
            <returns>True if the procedure exists</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.IfSchemaExistsTask">
            <summary>
            Checks if a schema exists. In MySql or MariaDb, use the IfDatabaseExistsTask instead.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfSchemaExistsTask.IsExisting(System.String)">
            <summary>
            hecks if the schema exists
            </summary>
            <param name="schemaName">The schema name that you want to check for existence</param>
            <returns>True if the schema exists</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfSchemaExistsTask.IsExisting(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            hecks if the schema exists
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="schemaName">The schema name that you want to check for existence</param>
            <returns>True if the schema exists</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.IfTableOrViewExistsTask">
            <summary>
            Checks if a table exists.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfTableOrViewExistsTask.IsExisting(System.String)">
            <summary>
            hecks if the table or view exists
            </summary>
            <param name="objectName">The table or view name that you want to check for existence</param>
            <returns>True if the table or view exists</returns>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.IfTableOrViewExistsTask.IsExisting(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            hecks if the table or view exists
            </summary>
            <param name="connectionManager">The connection manager of the database you want to connect</param>
            <param name="objectName">The table or view name that you want to check for existence</param>
            <returns>True if the table or view exists</returns>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.RowCountTask">
            <summary>
            Count the row in a table. This task normally uses the  COUNT(*) method (could take some time on big tables).
            You can pass a a filter condition for the count.
            </summary>
            <example>
            <code>
            int count = RowCountTask.Count("tableName").Value;
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.TableName">
            <summary>
            Name of the table on which the rows are counted
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.TN">
            <summary>
            The formatted table table name
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.Condition">
            <summary>
            Part of the sql where condition which restrict which rows are counted
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.Rows">
            <summary>
            Will hold the number of counted rows after execution
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.HasAnyRows">
            <summary>
            Indicates if the table contains rows - only has a value after the execution
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.QuickQueryMode">
            <summary>
            For Sql Server, you can set the QuickQueryMode to true. This will query the sys.partition table which can be much faster.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.DirtyRead">
            <summary>
            Will do the row count also on uncommitted reads.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.RowCountTask.Sql">
            <summary>
            The sql that is executed to count the rows in the table - will change depending on your parameters.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.RowCountTask.Count">
            <summary>
            Performs the row count
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.RowCountTask.HasRows">
            <summary>
            Checks if the table has at least one (matching) row.
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.RowCountOptions">
            <summary>
            Used in the RowCountTask. None forces the RowCountTask to do a normal COUNT(*) and works on all databases.
            QuickQueryMode only works on SqlServer and uses the partition table which can be much faster on tables with a big amount of data.
            DirtyRead does a normal COUNT(*) but also reading uncommitted reads. 
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.SqlTask">
            <summary>
            Executes any sql on the database. Use ExecuteNonQuery for SQL statements returning no data,
            ExecuteScalar for statements that return only one row and one column or
            ExecuteReader for SQL that returns multiple rows or columns
            </summary>
            <example>
            <code>
            SqlTask.ExecuteNonQuery("Description","insert into demo.table1 select * from demo.table2");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.SqlTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.SqlTask.#ctor(System.String)">
            <param name="sql">Sets the <see cref="P:ETLBox.ControlFlow.DbTask.Sql"/></param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.TruncateTableTask">
            <summary>
            Truncates a table.
            </summary>
            <example>
            <code>
            TruncateTableTask.Truncate("demo.table1");
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.TruncateTableTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.TruncateTableTask.Execute">
            <summary>
            Executes the table truncation.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.TruncateTableTask.TableName">
            <summary>
            Name of the table that should be truncated
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.TruncateTableTask.TN">
            <summary>
            The formatted table table name
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.TruncateTableTask.Sql">
            <summary>
            Sql code that is used when the task is executed.
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.TruncateTableTask.#ctor(System.String)">
            <param name="tableName">Sets the <see cref="P:ETLBox.ControlFlow.Tasks.TruncateTableTask.TableName"/></param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.TruncateTableTask.Truncate(System.String)">
            <summary>
            Execute a table truncation
            </summary>
            <param name="tableName">Table that should be truncated</param>
        </member>
        <member name="M:ETLBox.ControlFlow.Tasks.TruncateTableTask.Truncate(ETLBox.Connection.IConnectionManager,System.String)">
            <summary>
            Execute a table truncation
            </summary>
            <param name="tableName">Table name that should be truncated</param>
            <param name="connection">Database connection manager to connect with the database</param>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.XmlaTask">
            <summary>
            This task can exeucte any XMLA.
            </summary>
            <example>
            <code>
            XmlaTask.ExecuteNonQuery("Log description here","Xmla goes here...")
            </code>
            </example>
        </member>
        <member name="T:ETLBox.ControlFlow.Tasks.GetListTask">
            <summary>
            Returns a list of all user databases on the server. Make sure to connect with the correct permissions!
            In MySql, this will return a list of all schemas.
            </summary>
            <example>
            <code>
            GetDatabaseListTask.List();
            </code>
            </example>
        </member>
        <member name="P:ETLBox.ControlFlow.Tasks.GetListTask.ObjectNames">
            <summary>
            A list containing all databases after executing.
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.ITableData">
            <summary>
            A list of rows and a column mapping ready for bulk insert
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.ColumnMapping">
            <summary>
            The column mapping
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.Rows">
            <summary>
            Rows/Columns ready for bulk insert
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.CurrentRow">
            <summary>
            The row that is currently processed when accessing the data reader
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.ReadIndex">
            <summary>
            The row index of the current row
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.DestinationTableName">
            <summary>
            The name of the destination table
            </summary>
        </member>
        <member name="M:ETLBox.ControlFlow.ITableData.GetDataTypeName(System.String)">
            <summary>
            Resolves the data type name for a column
            </summary>
            <param name="columnName">Column name</param>
            <returns>Data type name</returns>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.Definition">
            <summary>
            Definition of the destination table
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.DataIndexForColumn">
            <summary>
            Resolves the index number for a column name
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ITableData.AllowIdentityInsert">
            <summary>
            If set to true, values in an indentity column are overwriten with the provided values
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ILoggableTask.TaskName">
            <summary>
            A name to identify the task or component. Every component or task comes
            with a default name that can be overwritten.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ILoggableTask.TaskType">
            <summary>
            A type description of the task or component. This is usually the class name.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ILoggableTask.TaskHash">
            <summary>
            Creates a unique hash value to identify the task or component.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.ILoggableTask.DisableLogging">
            <summary>
            If set to true, the component or task won't produce any log output.
            </summary>
        </member>
        <member name="T:ETLBox.ControlFlow.LoggableTask">
            <summary>
            This class contains properties that are needed for logging.
            </summary>
        </member>
        <member name="P:ETLBox.ControlFlow.LoggableTask.TaskType">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.LoggableTask.TaskName">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.LoggableTask.DisableLogging">
            <inheritdoc/>
        </member>
        <member name="P:ETLBox.ControlFlow.LoggableTask.TaskHash">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.ControlFlow.LoggableTask.CopyLogTaskProperties(ETLBox.ControlFlow.ILoggableTask)">
            <summary>
            Copies the relevant task properties from the current loggable task
            to another loggable task.
            </summary>
            <param name="otherTask">The target task that retrieve a copy from the log task properties</param>
        </member>
        <member name="T:ETLBox.Helper.BulkSqlGenerator`1">
            <summary>
            This class creates the necessary sql statements that simulate the missing bulk insert function in various database or Odbc/OleDb connections.
            Normally this will be a insert into with multiple values, but depending on the database type this can be different.
            </summary>
            <typeparam name="T">ADO.NET database parameter type</typeparam>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.UseParameterQuery">
            <summary>
            Indicates that the values are stored in parameter objects.
            Default is true.
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.UseNamedParameters">
            <summary>
            Indicates that the parameter variables in the sql have a name
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.Parameters">
            <summary>
            A list of parameters that contain the parameter objects for the generated sql query.
            Only has values if <see cref="P:ETLBox.Helper.BulkSqlGenerator`1.UseParameterQuery"/> is true.
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.AccessDummyTableName">
            <summary>
            When creating a bulk insert sql statement for Access, a dummy table is needed.
            The name of the dummy table is specified here.
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.ConnectionType">
            <summary>
            The type of the database that the bulk insert statement is designed for
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.QB">
            <summary>
            The quotatation begin character that the database uses. (E.g. '[' for SqlServer or '"' for Postgres)
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.QE">
            <summary>
            The quotatation end character that the database uses. (E.g. ']' for SqlServer or '"' for Postgres)
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.IsMariaDb">
            <summary>
            Indicates if the VALUES table descriptor needs the keyword ROW (MySql only)
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.AddDbTypesFromDefinition">
            <summary>
            If set to true, the parameter list will contain not only the object value, but also
            the DbType and Size of the parameter. This should only be necessary for SqlServer. 
            Default is false.
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.TryConvertParameterData">
            <summary>
            If set to true, the values for the parameters are tried to convert into the corresponding .NET 
            data type that is suitable for the corresponding database column. If a database column is of type INTEGER,
            but the input data is a string like "7", then the parameter value is converted into an System.Int32.
            The most ADO.NET connectors do this automatically, but this can be useful for Postgres. 
            Only works if <see cref="P:ETLBox.Helper.BulkSqlGenerator`1.AddDbTypesFromDefinition"/> is set to true.
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.AddParameterCastInSql">
            <summary>
            If set to true, the parameter name is encapsulated with a CAST expression.
            The datatype is the same data types used in the table definition.
            Only works if <see cref="P:ETLBox.Helper.BulkSqlGenerator`1.AddDbTypesFromDefinition"/> is set to true.
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.NoParameterForNulls">
            <summary>
            If <see cref="P:ETLBox.Helper.BulkSqlGenerator`1.UseParameterQuery"/> is set to true, 
            all values are written into parameter objects -including nulls.
            To avoid having parameters for null values, set this flag to true.
            Nulls will then be converted into "null" in the statement, and no parameter 
            is used.
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.TableName">
            <summary>
            The destination table name
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.HasNextRecord">
            <summary>
            Indicates if all data was read
            </summary>
        </member>
        <member name="P:ETLBox.Helper.BulkSqlGenerator`1.TableData">
            <summary>
            The data used for the bulk operation
            </summary>
        </member>
        <member name="M:ETLBox.Helper.BulkSqlGenerator`1.CreateBulkInsertStatement">
            <summary>
            Create the sql that can be used as a bulk insert.
            </summary>      
        </member>
        <member name="T:ETLBox.Helper.DataTypeConverter">
            <summary>
            This class provides static methods and an implementation of IDataTypeConverter that converts
            various sql data types into the right database specific database or into a .NET data type.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.GetStringLengthFromCharString(System.String)">
            <summary>
            Returns the string length that a sql char datatype has in it's definition.
            E.g. VARCHAR(40) would return 40, NVARCHAR2 ( 2 ) returns 2
            </summary>
            <param name="value">A sql character data type</param>
            <returns>The string length defined in the data type - 0 if nothing could be found</returns>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.GetTypeObject(System.String)">
            <summary>
            Returns the .NET type object for a specific sql type.
            E.g. the method would return the .NET type string for the sql type 'CHAR(10)'
            </summary>
            <param name="dbSpecificTypeName">The sql specific data type name</param>
            <returns>The corresponding .NET data type</returns>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.GetDBType(System.String)">
            <summary>
            Returns the ADO.NET System.Data.DbType object for a specific sql type.
            E.g. the method would return the System.Data.DbType.String for the sql type 'CHAR(10)'
            </summary>
            <param name="dbSpecificTypeName">The sql specific data type name</param>
            <returns>The corresponding ADO .NET database type</returns>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.TryConvertDbDataType(System.String,ETLBox.Connection.ConnectionManagerType)">
            <inheritdoc/>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.TryGetDbSpecificType(System.String,ETLBox.Connection.ConnectionManagerType)">
            <summary>
            Tries to convert the data type into a database specific type.
            E.g. the data type 'INT' would be converted to 'INTEGER' for SQLite connections.
            </summary>
            <param name="dataTypeName">A data type name</param>
            <param name="connectionType">The database connection type</param>
            <returns>The converted database specific type name</returns>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.TryConvertAliasName(System.String,ETLBox.Connection.ConnectionManagerType)">
            <summary>
            Converts a data type alias name (e.g. an alias name
            like "varchar(10)" ) to the original database type name ("character varying").
            </summary>
            <param name="dataTypeName">The database alias type name</param>
            <param name="connectionType">Which database (e.g. Postgres, MySql, ...)</param>
            <returns>The type name converted to an original database type name</returns>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.GetClrType(System.Data.DbType)">
            <summary>
            Returns a .NET type for the provided DbType. 
            E.g. DbType.Binary will return byte[]
            </summary>
            <param name="dbType">The DbType</param>
            <returns>A .NET type</returns>
        </member>
        <member name="M:ETLBox.Helper.DataTypeConverter.GetDatabaseType(System.Type,ETLBox.Connection.ConnectionManagerType)">
            <summary>
            Returns a database specific type for the provided .NET datat type, depending on the connection
            manager. E.g. passing the .NET data type long for SqlServer will return the string BIGINT 
            </summary>
            <param name="clrType">The .NET data type</param>
            <param name="connectionType">Database connection type, e.g. SqlServer</param>
            <returns>A database specific type string</returns>
        </member>
        <member name="T:ETLBox.Helper.HashHelper">
            <summary>
            This class creates unique strings containing hash values.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.HashHelper.CreateChar40Hash(System.String)">
            <summary>
            Creates a 40 character unique hash string
            </summary>
            <param name="text">Text that needs to be hashed</param>
            <returns>A unique readable hash string with 40 characters</returns>
        </member>
        <member name="M:ETLBox.Helper.HashHelper.CreateChar40Hash(ETLBox.ControlFlow.ILoggableTask)">
            <summary>
            Creates a unique hash string from a loggable task
            </summary>
            <param name="task">The ETLBox loggable task</param>
            <returns>A unique readable hash string with 40 character</returns>
        </member>
        <member name="M:ETLBox.Helper.HashHelper.HashSum(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Addition of the hash values for a list of object
            </summary>
            <param name="objectList">A list of objects</param>
            <returns>A unique hash value</returns>
        </member>
        <member name="T:ETLBox.Helper.ObjectNameDescriptor">
            <summary>
            Applies database specific formatting to an object names.
            E.g. schema.ViewName would create [schema].[ViewName] for SqlServer and "schema"."ViewName" for Postgres
            </summary>
              
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.ObjectName">
            <summary>
            The name of the object that needs to have database spcific formatting applied
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.QB">
            <summary>
            The quotation begin character that is used in the database.
            E.g. SqlServer uses: '[' and Postgres: '"'
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.QE">
            <summary>
            The quotation end character that is used in the database.
            E.g. SqlServer uses: ']' and Postgres: '"'
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.QuotatedObjectName">
            <summary>
            The object name with quotes.
            E.g. schema.ViewName would create "ViewName"
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.UnquotatedObjectName">
            <summary>
            The object name without any quoting.
            E.g. "schema"."ViewName" would create ViewName
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.UnquotatedSchemaName">
            <summary>
            The schema name without any quoting.
            E.g. "schema"."ViewName" would create schema
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.QuotatedSchemaName">
            <summary>
            The schema name with quotes.
            E.g. "schema"."ViewName" would create "schema"
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.QuotatedFullName">
            <summary>
            The whole name with quotes.
            E.g. schema.ViewName would create "schema"."ViewName"
            </summary>
        </member>
        <member name="P:ETLBox.Helper.ObjectNameDescriptor.UnquotatedFullName">
            <summary>
            The whole name without any  quotation
            E.g. "schema"."ViewName" would create schema.ViewName
            </summary>
        </member>
        <member name="M:ETLBox.Helper.ObjectNameDescriptor.#ctor(System.String,System.String,System.String)">
            <summary>
            Creates a new instance and already parses the values. Right after initialization you can access the values in the properties.
            </summary>
            <param name="objectName">The full object name (e.g. Schema.ViewName)</param>
            <param name="qb">The database specific quotation start (e.g. '[' for Sql Server)</param>
            <param name="qe">The database specific quotation start (e.g. ']' for Sql Server)</param>
        </member>
        <member name="T:ETLBox.Helper.SqlParser">
            <summary>
            Helper class for parsing sql statements
            </summary>
        </member>
        <member name="M:ETLBox.Helper.SqlParser.ParseColumnNames(System.String)">
            <summary>
            This method attempts to parse column names from any sql statement.
            E.g. SELECT 1 AS 'Test', Col2, t2.Col3 FROM table1 t1 INNER JOIN t2 ON t1.Id = t2.Id
            will return Test, Col2 and Col3 als column names.
            </summary>
            <param name="sql">The sql code from which the column names should be parsed</param>
            <returns>The names of the columns in the sql</returns>
        </member>
        <member name="T:ETLBox.Helper.StringExtension">
            <summary>
            Extension methods for strings
            </summary>
        </member>
        <member name="M:ETLBox.Helper.StringExtension.ReplaceIgnoreCase(System.String,System.String,System.String)">
            <summary>
            	This replicates the functionality of case-insensitive functionality built into Replace in .Net Core.
            </summary>
            <param name="toSearch"></param>
            <param name="find"></param>
            <param name="replace"></param>
            <returns>The string with replaced values</returns>
        </member>
        <member name="T:ETLBox.Helper.IDataTypeConverter">
            <summary>
            Describe methods that allows to intercept the CREATE TABLE sql generation in a CreateTableTask.
            It will convert the data type that is defined in a TableColumn into a custom database specific type.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.IDataTypeConverter.TryConvertDbDataType(System.String,ETLBox.Connection.ConnectionManagerType)">
            <summary>
            Tries to convert the data type from the TableColumn into a database specific type.
            </summary>
            <param name="dataTypeName">The specific type name from a table column</param>
            <param name="connectionType">The database connection type</param>
            <returns>The type used in the CREATE TABLE statement</returns>
        </member>
        <member name="T:ETLBox.Helper.PropertyInfoExtension">
            <summary>
            Reflection helper class that allows to directly set values in properties.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.PropertyInfoExtension.SetValueOrThrow(System.Reflection.PropertyInfo,System.Object,System.Object,System.Type)">
            <summary>
            Sets a value in a property. If this is not possible, this method throws an exception.
            </summary>
            <param name="pi">The property info for the property</param>
            <param name="obj">The object that contains the property</param>
            <param name="value">The new value for the property</param>
        </member>
        <member name="M:ETLBox.Helper.PropertyInfoExtension.TrySetValue(System.Reflection.PropertyInfo,System.Object,System.Object,System.Type)">
            <summary>
            Tries to set a value in a property. If not possible, it will do nothing.
            </summary>
            <param name="pi">The property info for the property</param>
            <param name="obj">The object that contains the property</param>
            <param name="value">The new value for the property</param>
            <param name="enumType">If the property is an enum type, this will need special handling - pass the enum type here. Default value is null.</param>
        </member>
        <member name="T:ETLBox.Helper.PushStreamContent">
            <summary>    
            Provides an <see cref="T:System.Net.Http.HttpContent"/> implementation that exposes an output <see cref="T:System.IO.Stream"/>
            which can be written to directly. The ability to push data to the output stream differs from the 
            <see cref="T:System.Net.Http.StreamContent"/> where data is pulled and not pushed.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.#ctor(System.Action{System.IO.Stream,System.Net.Http.HttpContent,System.Net.TransportContext})">
            <summary>
            Initializes a new instance of the <see cref="T:ETLBox.Helper.PushStreamContent"/> class. The
            <paramref name="onStreamAvailable"/> action is called when an output stream
            has become available allowing the action to write to it directly. When the 
            stream is closed, it will signal to the content that is has completed and the 
            HTTP request or response will be completed.
            </summary>
            <param name="onStreamAvailable">The action to call when an output stream is available.</param>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.#ctor(System.Func{System.IO.Stream,System.Net.Http.HttpContent,System.Net.TransportContext,System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:ETLBox.Helper.PushStreamContent"/> class. 
            </summary>
            <param name="onStreamAvailable">The action to call when an output stream is available. The stream is automatically
            closed when the return task is completed.</param>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.#ctor(System.Action{System.IO.Stream,System.Net.Http.HttpContent,System.Net.TransportContext},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ETLBox.Helper.PushStreamContent"/> class with the given media type.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.#ctor(System.Func{System.IO.Stream,System.Net.Http.HttpContent,System.Net.TransportContext,System.Threading.Tasks.Task},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ETLBox.Helper.PushStreamContent"/> class with the given media type.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.#ctor(System.Action{System.IO.Stream,System.Net.Http.HttpContent,System.Net.TransportContext},System.Net.Http.Headers.MediaTypeHeaderValue)">
            <summary>
            Initializes a new instance of the <see cref="T:ETLBox.Helper.PushStreamContent"/> class with the given <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue"/>.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.#ctor(System.Func{System.IO.Stream,System.Net.Http.HttpContent,System.Net.TransportContext,System.Threading.Tasks.Task},System.Net.Http.Headers.MediaTypeHeaderValue)">
            <summary>
            Initializes a new instance of the <see cref="T:ETLBox.Helper.PushStreamContent"/> class with the given <see cref="T:System.Net.Http.Headers.MediaTypeHeaderValue"/>.
            </summary>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.FromResult``1(``0)">
            <summary>
            Returns a successful completed task with the given result.  
            </summary>        
        </member>
        <member name="T:ETLBox.Helper.PushStreamContent.AsyncVoid">
            <summary>
            Used as the T in a "conversion" of a Task into a Task{T}
            </summary>
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
            <summary>
            When this method is called, it calls the action provided in the constructor with the output 
            stream to write to. Once the action has completed its work it closes the stream which will 
            close this content instance and complete the HTTP request or response.
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to which to write.</param>
            <param name="context">The associated <see cref="T:System.Net.TransportContext"/>.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> instance that is asynchronously serializing the object's content.</returns>        
        </member>
        <member name="M:ETLBox.Helper.PushStreamContent.TryComputeLength(System.Int64@)">
            <summary>
            Computes the length of the stream if possible.
            </summary>
            <param name="length">The computed length of the stream.</param>
            <returns><c>true</c> if the length has been computed; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:ETLBox.Helper.DelegatingStream">
            <summary>
            Stream that delegates to inner stream.
            This is taken from System.Net.Http
            </summary>
        </member>
        <member name="T:ETLBox.Logging.Logging">
            <summary>
            Contains static information which affects all ETLBox tasks and general logging behavior for all components.
            Here you can set default connections string, disable the logging for all processes or set the current stage used in your logging configuration.
            </summary>
        </member>
        <member name="P:ETLBox.Logging.Logging.DisableAllLogging">
            <summary>
            This is the default value for all control and dataflow components. If set to true, no log messages will be produced.
            Logging can be enabled/disabled for all components individually using the DisableLogging property on each component. 
            </summary>
        </member>
        <member name="P:ETLBox.Logging.Logging.STAGE">
            <summary>
            For logging purposes only. If the stage is set, you can access the stage value in the logging configuration.
            </summary>
        </member>
        <member name="P:ETLBox.Logging.Logging.CurrentLoadProcess">
            <summary>
            If you used the logging task StartLoadProces (and created the corresponding load process table before)
            then this Property will hold the current load process information.
            </summary>
        </member>
        <member name="P:ETLBox.Logging.Logging.LoadProcessTable">
            <summary>
            TableName of the current load process logging table
            </summary>
        </member>
        <member name="F:ETLBox.Logging.Logging.DEFAULTLOGTABLENAME">
            <summary>
            The default log table name
            </summary>
        </member>
        <member name="P:ETLBox.Logging.Logging.LogTable">
            <summary>
            TableName of the current log process logging table
            </summary>
        </member>
        <member name="M:ETLBox.Logging.Logging.ClearSettings">
            <summary>
            Set all settings back to default (which is null or false)
            </summary>
        </member>
        <member name="T:ETLBox.Logging.CreateErrorTableTask">
            <summary>
            This task will create a table that can store exceptions (and information about the affected records)
            that occur during a data flow execution
            </summary>
        </member>
        <member name="T:ETLBox.Logging.LoadProcessTask">
            <summary>
            Let you manage load process logging.
            You can start, stop and abort load processes with this task. 
            It also allows you to create a the required table in your database.
            </summary>
        </member>
        <member name="T:ETLBox.Logging.LogSection">
            <summary>
            A log section will execute your code block, wrapping the action with log messages indicating start and end.
            </summary>
        </member>
        <member name="P:ETLBox.Logging.LogSection.TaskName">
            <inheritdoc/>
        </member>
        <member name="T:ETLBox.Logging.LogTask">
            <summary>
            Used this task for custom log messages.
            </summary>
        </member>
        <member name="T:ETLBox.Exceptions.ETLBoxException">
            <summary>
            The generic ETLBox Exception. See inner exception for more details.
            </summary>
        </member>
        <member name="T:ETLBox.Exceptions.ETLBoxFaultedBufferException">
            <summary>
            The generic ETLBox Exception. See inner exception for more details.
            </summary>
        </member>
        <member name="T:ETLBox.Exceptions.ETLBoxNotSupportedException">
            <summary>
            The generic ETLBox Exception. See inner exception for more details.
            </summary>
        </member>
    </members>
</doc>
